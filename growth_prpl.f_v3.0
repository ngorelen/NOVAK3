c**********************************************************************
c This subroutine is modified from the original growth to allow the
c calculation of the principal part of the dW_k
      subroutine growth_prpl(ai,aeqv,b0oo,deltk,dfalp,dfalpdv
     &     ,dpga,dintgr,fo,hnub,hnub_se,hwb1,mt,mtl,nnres,eps,
     &     epsp,gamkom,gamkomflr,iav,im1,iter,immax,isrfmax,ntgr,
     &     nosurf,nroot,omkom,omkomflr,p0ga,pk,psiavres,psitot,rfres,
     &     rma,rmi,symm,vi,vres,scalvavf,tip,xfow,zi,istart)
c Thie choice of grid is for M=1 mode stability analysis
      include 'orbit.grid'
      include 'clichlmax'
c
      parameter (iav1=6,iberk=30,mtl_m1=maxm_1-minm_1+2)
      parameter(nres2=2)
      dimension qpf(npf),pmu(nmu),v(nv),wvpr(nv,nmu,npf,2),fo(iav,mt,
     &     -mtl:mtl,nnres),wqvpr(nv,nmu,npf,2),wd(nv,nmu,npf,2),wb(nv
     &     ,nmu,npf,2),wres(nv),vres(nnres,-mtl:mtl),gamintpfi(npf,6,2)
     &     ,gamintmu(nmu,8),rf(2,6,nmu,nv),vplot(nv,nmu,4),ind(nv)
c
     &     ,dfdfdvdr(npf,nmu,-mtl_m1:mtl_m1,2,2)
      dimension rfres(2,6,nnres,-mtl:mtl),gamkomis(6,2),psiav(nv,nmu
     &     ,npf,2),gtrap(npf,6),dintgr(-mtl:mtl,nnres,4,2),gtrap1(6)
     &     ,nroot(-mtl:mtl),dfalp(nnres,-mtl:mtl),dfalpdv(nnres,-mtl:
     &     mtl),aeqv(nnres,-mtl:mtl),psiavres(nnres,-mtl:mtl)
     &     ,dfgapdv(nres2,-mtl_m1:mtl_m1),tbch(nres2,-mtl_m1:mtl_m1)
      dimension dbob(iberk),gberkintmu(nmu,iberk,4)
     &     ,gberkintpfi(npf,iberk,8),gberkis(iberk,8),hwb1(nnres,
     &     -mtl:mtl),hnub(nnres,-mtl:mtl),hnub_se(nnres,-mtl:mtl)
     &     ,hchirp(2,nres2,-mtl_m1:mtl_m1),gberkimuch(nmu,2)        ! chrp arrays
     &     ,gberkipfich(npf,2,2),gberkisch(2,2)
     &     ,gbimuch(nmu,iberk,iberk),gbipfich(npf,iberk,iberk,2),
     &     gbisch(iberk,iberk,2),gbiscl(iberk),gbimap(iberk,iberk)  ! chrp stblty
     &     ,gbidrgavmu(nmu,4),gbidrgavipfi(npf,2,4),gbidrgavis(2,4) ! first 2's are for is
                                                                    ! second is for scatt/drag
     &     ,wresPfiV(npf,nv)
     &     ,gbimuch0(nmu),gbipfich0(npf,2),gbisch0(2)
c#ifdef _dev 
c#endif
c stuff for m1 study
      dimension rf_m1(2,6,nv),fo_m1(iav1,nv,mtl_m1,-mtl_m1:mtl_m1)
     &     ,dwv_m1(iav1,-mtl_m1:mtl_m1),dfalpdv_m1(nv,-mtl_m1:mtl_m1)
     &     ,omintmu(nmu,2),omintpfi(npf,2),omkomis(2),i_m1(nv,
     &     -mtl_m1:mtl_m1),wres_m1(nv,-mtl_m1:mtl_m1)
      common/wdr/alpha,b0ax,psedge,vioo,sigvpr
      common/cgm/b0,brz,pmui,qpfi,z0,imtae0,imt
      common/fast/xav,xavint,x2r,x2i,psioo,kfast
      save rf
ckg_sat amplitude saturation stuff 
      dimension 
c      common/lbq_sat/??? may give some errors during the compilation???
     &     vres_sat(npf,nmu,-mtl_m1:mtl_m1,2,2),
     &     fdist_sat(npf,nmu,-mtl_m1:mtl_m1,2,2),
     &     gam_sat(npf,nmu,-mtl_m1:mtl_m1,2,2),
     &     grps2(1000),rgrid(1000),
     &     vgam_sat(npf,nmu,-mtl_m1:mtl_m1,2,2),
     &     dwv_sat(npf,nmu,-mtl_m1:mtl_m1,2,2),
     &     dwp_sat(npf,nmu,-mtl_m1:mtl_m1,2,2),
     &     bgy_sat(npf,nmu,-mtl_m1:mtl_m1,2,2)
     &     ,hnub_sat(npf,nmu,-mtl_m1:mtl_m1,2,2)
     &     ,tbres_sat(npf,nmu,-mtl_m1:mtl_m1,2,2)
     &     ,wbwpi_sat(npf,nmu,-mtl_m1:mtl_m1,2,2)
c  in the indexing scheme we specify two numbers for important bounce harmonics to keep
     &     ,indx_sat(nmu,2),
#ifdef dumpdf
     &     f_coarse(nv,nmu,npf,2),hnub_coarse(nv,nmu,npf,2),
#endif
     &     dwpmnmz_sat(npf,nmu,-mtl_m1:mtl_m1,2,2),
     &     d2wpmnmz_sat(npf,nmu,-mtl_m1:mtl_m1,2,2),
     &     meigfun(npf,nmu,-mtl_m1:mtl_m1,2,2) ! first harmonic in res. sequence to gxm file
c modify Xin files variable
      character c46*46/'ls'/,cgw*60
      logical transp_exist
      character runid*90,egnid*15,nus*18
ckg_plot the distribution function
      dimension fplot(npf,nmu,2),fplot1(nmu,nv,2),fplot2(nmu,2,nv)
     &     ,gc2(nmu,2,nv)
      character*40 labtitle
c_________graph\/staff
      character col(npf),pat(npf),tip*1,fow*11,filename*11
      complex wtae
      data omkomis/2*0./,gamkomis/12*0./,gtrap1/6*0./
      gamintpfi=0.                              ! following eqlts avoid complains with --chk flag
      omintpfi=0.
      gtrap=0.
      gberkintpfi=0.
      gberkis=0.
      gberkipfich=0.
      gberkisch=0.
      gbipfich=0.
      gbipfich0=0.
      gbisch=0.
      gbisch0=0.
      wd=0.
      wb=0.
      psiav=0.
      psiavres=0.
      wvpr=0.
      wqvpr=0.
      dbob=0.
      gberkintmu=0.
      gberkintpfi=0.
      gberkis=0.
      hwb1=0.
      hnub=0.
      hnub_se=0.
      hchirp=0.
      gberkimuch=0.
      gberkipfich=0.
      gberkisch=0.
      gbimuch=0.
      gbipfich=0.
      gbisch=0.
      gbiscl=0.
      gbimap=0.
      gbidrgavmu=0.
      gbidrgavipfi=0.
      gbidrgavis=0.
      rf=0.
      rfres=0.
c      if(mt_m1.lt.mt)write(*,*) mt_m1, mt,
c     &     'warning: check your dimension of MT in GROWTH'
      write(fow(5:8),'(f4.2)') xfow
      do i=1,npf
         col(i)='white'
         pat(i)='solid'
      enddo
c---------graph/\temporary
c========== definitions for integrations
      psma=bfo(b,b0,(rmi+rma)/2.,r0,0.,z0)
      psma=psio(dpsi,ddpsi,dzpsi,rma,r0,z0,z0,am)
      psmi=psio(dpsi,ddpsi,dzpsi,rmi,r0,z0,z0,am)
      call eigenmod(b0oo,b0,dbobmax,dbobmaxs,dnonmax,grps2(1),rgrid(1),
     &     min,min_f,max,max_f,ntae,scalvavf,valfv,wtae,deltk,ximax)
      write(*,*) ' max of Xi[m],dB/B,dB/B_sin and dn/n are',ximax
     &     ,dbobmax,dbobmaxs,dnonmax
      call rescondif(ai,alpha,b0,b0oo,eps,epsp,im1,iter,ntgr
     &     ,psiav,psitot,psma,psmi,pmu,nmu,qpf,npf,r0,rf,rma
     &     ,rmi,symm,t0,tip,valfv,v,nv,vi,z0,zi,wvpr,wqvpr,wd,wb
     &     ,xfow,xhp)
c
      call eigenmod(b0oo,b0,dbobmax,dbobmaxs,dnonmax,grps2(1),rgrid(1),
     &    min,min_f,max,max_f,ntae,scalvavf,valfv,wtae,deltk,ximax)
ckg convert the frequency to the shifted by the cyclotron frequency
ckg by multiplying by -3.7, so from -415 kHz it is changed to 1545kHz
c      wtae=-wtae*(3.7)
      call berkgrid(dbob,iberk,dbobmax,ximax)
      write(*,*) 'm range ',min,max,'ntae ',ntae,'Signif.m`s are',min_f
     &     ,max_f
      write(*,*) 'om= ',wtae,'x10^6 rad^-1; f= ',real(wtae)/2./3
     &     .1415926,'x10^3 kHz'
      write(*,*) ' Delta K= ',deltk,' Valfven=',valfv
      write(*,*) ' Va/Valfv=',vi/valfv,' xFOW=',xfow,' Type=',tip
      write(*,*) ' Alpha`s A,Z,V_0', ai,zi,vi
      write(*,*) 'B_0 (T)',b0*b0oo,' R_ax',r0,' Z_ax',z0
      write(*,*) 'Psi_edge=',psitot
      b0ax=b0
      psedge=psma
      vioo=vi
c  Here gam is the parameter so that the df is
c  f~/(v^3 + v*^3)^(2-gam) and gam=1 corresponds to the slowing down df.
      gam=1.
      gamkom=16.18282*ai**2*vi**4*sign(abs(wtae),real(wtae))/xhp/zi
     &     /b0oo/b0/4./deltk/r0
      gamkomhlp=gamkom
      omstari=real(ntae)*xhp*vi*10.
      omstar=omstari/sign(abs(wtae),real(wtae))
      write(*,*) 'omstar=',omstar
ckg Note that it is assumed negative for frequency to be in the
c      resonance with particles
c
c This one is for JT60 27969 assuming the frequency of fishbone like
c perturbations were 30kHz
c      if(im1.eq.2) wtae=wtae-0.1885
      w_rotres=0.
      call omstari_calc(ai,omstari,vi,zi)
cnng13 analytic rotation
      if(im1.ne.0) then
c         wtae=(0.,0.)
         w_rot0=0.
         w_rot1=0.
c this determines the rotation from transp run
         p_rot=1.
cben minimize rotation approximation functional to find the rotation constants
         call readrot(w_rot0,w_rot1,p_rot,ierr)
         write(*,*) 'TRANSP given rotation is',
     &        w_rot0,w_rot1,p_rot,ierr,im1
c this key switch off the rotation definition from transp, it is 0 if normal
c         ierr=0
         if(ierr.eq.1)then
            w_rot0=0.06
            w_rot1=0.01
c rotation frequencies are read in my units 10^6 rad/sec^-1
         endif
         if(im1.eq.3) then
            w_rotres=psi_indx(isrfmax)
         else
            call psi_res(w_rotres)
         endif
         w_rotres=w_rot0-w_rotres**p_rot*(w_rot0-w_rot1)
         write(*,*) 'To include rotation use w_rot0=',w_rot0
     &        ,' w_rot1=',w_rot1,' w_rotres=',w_rotres
      endif
      write(*,*) 'om= ',wtae,'f= ',real(wtae)/2./3.1415926
      is1=1
      ipf1=1
      write(fow(1:4),'(f4.2)') scalvavf
      if(ai.eq.4..and.tip.ne.'i')then
         filename='gam'//fow(1:1)//fow(3:4)//'.'//fow(5:5)//fow(7:8)/
     &        /'a'
         ihsps=3
      else if(ai.eq.1..and.tip.ne.'i')then
         filename='gam'//fow(1:1)//fow(3:4)//'.'//fow(5:5)//fow(7:8)/
     &        /'h'
         ihsps=3
      else if(ai.eq.2..and.tip.ne.'i')then
         filename='gam'//fow(1:1)//fow(3:4)//'.'//fow(5:5)//fow(7:8)/
     &        /'d'
         ihsps=1
      else if(ai.eq.3..and.zi.eq.2.and.tip.eq.'h')then
         filename='gam'//fow(1:1)//fow(3:4)//'.'//fow(5:5)//fow(7:8)/
     &        /'he3'
         ihsps=2
      else if(ai.eq.3.)then
         filename='gam'//fow(1:1)//fow(3:4)//'.'//fow(5:5)//fow(7:8)/
     &        /'t'
         ihsps=2
      else if(tip.eq.'i')then
         filename='gam'//fow(1:1)//fow(3:4)//'.'//fow(5:5)//fow(7:8)/
     &        /'Di'
         ihsps=3
      else
         filename='gam'//fow(1:1)//fow(3:4)//'.'//fow(5:5)//fow(7:8)/
     &        /'?'
         ihsps=3
         write(*,*)
     &        '?????????warning:  Your particle weight is uncommon'
      endif
      open(unit=18,err=10,file=filename,status='old')
c      read(18,*,err=10,end=10) is1,ipf1
      read(18,*,err=10,end=10) gamkomis,omkomis,gtrap1
      if(is1.eq.1)call zero(omkomis(1),2)
      read(18,*,err=10,end=10) gamintpfi
      read(18,*,err=10,end=10) omintpfi
      read(18,*,err=10,end=10) gtrap
      read(18,*,err=10,end=10) gberkintpfi
      read(18,*,err=10,end=10) gberkis
      read(18,*,err=10,end=10) gberkipfich
      read(18,*,err=10,end=10) gberkisch
      read(18,*,err=10,end=10) gbipfich,gbipfich0
      read(18,*,err=10,end=10) gbisch,gbisch0
      write(*,*) 'Using old file ',filename
 10   continue
      close(18)
      call zero(dintgr(-mtl,1,1,1),nnres*(2*mtl+1)*8)
c   define scaling factors to use in chirping criterion with more grid density at origin
      gbscmin=0.5
      gbscmax=2.
      do i=1,iberk
         gbiscl(i)=gbscmin+(gbscmax-gbscmin)*((i-0.99999)/(iberk-1))**1
      enddo
c
      itest=0 
c the test is only initiated if _test is defined during the compilation
#ifdef _test
      itest=1
#endif
      if(itest.eq.1)then
c         symm=1.
         is1t=1
         is2t=1
c is1t
c
c         ipf1t=indx(qpf(1),npf,1.)
c at 100,50 runs OK if the broadened region is gdp2pf=0.1 inside fungw0 
         ipf1t=1
         ipf2t=npf
         ipf1t=65
         ipf2t=ipf1t
c
         imu1t=1
c         imu1t=1                !8
c         imu2t=nmu              !8
         imu1t=97
         imu2t=97
c To test for each bounce harmonics:
c make it(itestil) =10 to see all the resonance condition or =1 for simpler
c output or it = 20 for m1 stability
c no extra output if =30 just run with limited l numbers
         itestil=10
         il1t=-mtl
         il2t=mtl
         il1t=-6
         il2t=-5
c
c
c         il1t=-6                !define here il{1,2}t for itestil=1,10,30
c
c
c         il2t=il1t+4
c To test for each mode harmonics:
         itestm=0
c allows to work only with harmonics at such numbers, which are the
c poloidal numbers, which differs from Max M value printed!!!!
         im1t=min_f
         im2t=max_f
c         im1t=5
c         im2t=6
      else
         im1t=min_f
         im2t=max_f
         il1t=-mtl
         il2t=mtl
         is1t=is1
         is2t=2
         ipf1t=ipf1
         ipf2t=npf
         imu1t=1
         imu2t=nmu
         itestil=0
         itestm=0
         if(im1.eq.1)is2t=1
      endif
      if(tip.eq.'c'.or.tip.eq.'r')then
         is1t=1
         is2t=1
      endif
      do is=is1t,is2t
         sigm=1.
         if(is.eq.2) sigm=-1.
ctem
         if(im1.eq.1.and.itest.ne.1)ipf2t=npf*3/4
c         if(tip.eq.'r')then
c            ipf1t=npf*3/7.
c            ipf2t=npf*5/7.
c         endif
         do ipf=ipf1t,ipf2t
            imlmax=0
            imtamax=0
            qpfi=qpf(ipf)
            do ib=1,iberk
               gberkintpfi(ipf,ib,2*is-1)=0.
               gberkintpfi(ipf,ib,2*is)=0.
               gberkintpfi(ipf,ib,4+is)=0.
               gberkintpfi(ipf,ib,6+is)=0.
            enddo
            gberkipfich(ipf,1,is)=0.
            gberkipfich(ipf,2,is)=0.
            do idrg=1,iberk
               do isct=1,iberk
                  gbipfich(ipf,idrg,isct,is)=0.
               enddo
            enddo
            gbipfich0(ipf,is)=0.
            gbidrgavipfi(ipf,is,1)=0.
            gbidrgavipfi(ipf,is,2)=0.
            gbidrgavipfi(ipf,is,3)=0.
            gbidrgavipfi(ipf,is,4)=0.
            gamintpfi(ipf,4,is)=0.
            gamintpfi(ipf,3,is)=0.
            omintpfi(ipf,1)=0.
            omintpfi(ipf,2)=0.
            if(is.eq.1) then
               gtrap(ipf,3)=0.
               gtrap(ipf,4)=0.
            endif
c
            deltqx=sigm*(qpf(npf)-qpf(1)-1.)/2.
            ilmax=-1000
            ilmin=1000
            imu_m1=0
            do imu=imu1t,imu2t
               pmui=pmu(imu)
               do ib=1,iberk
                  gberkintmu(imu,ib,1)=0.
                  gberkintmu(imu,ib,2)=0.
                  gberkintmu(imu,ib,3)=0.
                  gberkintmu(imu,ib,4)=0.
               enddo
               gberkimuch(imu,1)=0.
               gberkimuch(imu,2)=0.
               do idrg=1,iberk
                  do isct=1,iberk
                     gbimuch(imu,idrg,isct)=0.
                  enddo
               enddo
               gbimuch0(imu)=0.
               gbidrgavmu(imu,1)=0.
               gbidrgavmu(imu,2)=0.
               gbidrgavmu(imu,3)=0.
               gbidrgavmu(imu,4)=0.
               do ki=1,8
                  gamintmu(imu,ki)=0.
                  if(ki.lt.3)omintmu(imu,ki)=0.
               enddo
               call zero(aeqv,nnres*(mtl*2+1))
               if(pmui.gt.rmi.and.sigm.gt.0.) then
                  ml1=1
                  kl1=0
               else
                  ml1=abs(ntae)
                  kl1=1
               endif
               if(imu.eq.imu1t.or.imtamax.eq.0)then
                  min1=min_f
                  max1=max_f
               else
c ??? uluchshit'
                  deltqx=amax1(qpfi+deltqx*(1.-pmui/r0),0.)
                  deltqx=amin1(deltqx,1.)*(.6+pmui/r0)/1.6
                  mdelt=(abs(ntae)+deltqx**2
     $                 *(abs(max))*1.)
                  mdelt=min0(mdelt,int(2*abs(ntae)))
                  mdelt=max0(2,mdelt)
                  if(mod(imu,2).ne.1)then
                     min1=max0(imtamax-2,min_f)
                     max1=min0(imtamax+3,max_f)
c                     min1=max0(imtamax-6,min_f)
c                     max1=min0(imtamax+5,max_f)
                  else
                     min1=max0(imtamax-mdelt,min_f)
                     max1=min0(imtamax+mdelt,max_f)
                  endif
               endif
c
c               if(itest.eq.1)then
c                  min1=min_f
c                  max1=max_f
c               endif
               if(itestm.eq.1)then
                  min1=im1t
                  max1=min0(im2t,max_f)
               endif
               if(imu.eq.imu1t.or.(pmui.gt.rmi.and.sigm.gt.0.).or.imlmax
     &              .eq.0)then
                  ml2=-ml1*sigm+5
                  if(ml2.lt.imlmax+5) ml2=imlmax+5
                  ml10=-ml1*(1-(-sigm+1)/2)*sigm-2
                  il=min0(abs(ntae),10)
                  if(ml10.gt.imlmax-il)ml10= imlmax-il
c     $                 *sign(1.,real(ntae))
                  if(im1.eq.2)then
                     if(mod(imu,3).eq.0) then
                        ml2=mtl
                        ml10=-mtl
                     else
                        ml2=imlmax
                        ml10=ml2
                     endif
                  endif
               else
c                  ml2=imlmax+5
c                  ml10=imlmax-abs(ntae)*2-2
                  ml2=imlmax+5
                  ml10=min0(abs(ntae)*2,10)
                  ml10=max0(imlmax-ml10,ilmin)
                  if(im1.eq.2)then
                     if(mod(imu-1,5).eq.0) then
                        ml2=mtl
                        ml10=-mtl
                     else
                        ml2=imlmax
                        ml10=ml2
                     endif
                  endif
               endif
c
               if(imu.gt.imu1t.and.mod(imu,5).eq.0)then
                  ml2=min0(mtl,ilmax)
                  ml10=max0(-mtl,ilmin)
               endif
               if(itestil.eq.1.or.itestil.eq.10.or.itestil.eq.30)then
                  ml10=il1t
                  ml2=il2t
               endif
               if(ml2.gt.mtl)ml2=mtl
               if(ml10.lt.-mtl)ml10=-mtl
               call zero(dfalpdv_m1(1,-mtl_m1),nv*(2*mtl_m1+1))
               ilmax=-1000
               ilmin=1000
               do imtae=min1,max1
                  imtae0=imtae+1-min
c     hereafter the summ over the bounce harmonics
c
c     m1 here changes are made for M1
                  if(im1.eq.1) then
                     ml10=0
                     ml2=0
                  endif
                  if(itest.eq.1.and.itestil.eq.0)then
                     ml2=mtl
                     ml10=-mtl
                  endif
ckg for test purposes to include all the harmonics, more computation
c                     ml2=mtl
c                     ml10=-mtl
                  do il=ml10,ml2
                     if(imtae.eq.min1)then
                        nres=0
                        ires0=0
                        if(itestil.eq.10.or.itestil.eq.20)write(*,*)
     &                   ' V, <V_||>, W_d, W_b, W_res,qav,psiav; m,l'
     &                       ,imtae0,il
                        do iv=1,nv
                           if(ires0.eq.0.and.abs(wb(iv,imu,ipf,is))
     $                          .gt.1.e-10) then
                              ires0=iv
                           endif
                           if(ires0.ne.0.and.abs(wb(iv,imu,ipf,is))
     $                          .gt.1.e-10) nres=nres+1
                           q_av=q_psi(psiav(iv,imu,ipf,is))
c      a0=2.5
c      a1=.3
c         ppsi(i)=a0-ppsi(i)*(a0-a1)
                           wres(iv)=-ntae*(wqvpr(iv,imu,ipf,is)+wd(iv
     &                          ,imu,ipf,is))+real(wtae)
                           if(il.eq.ml10.and.abs(wb(iv,imu,ipf,is))
     $                          .gt.1.e-10)then
                              iltest=-int(wres(iv)/wb(iv
     &                             ,imu,ipf,is))
                              ilmax=max0(ilmax,iltest)
                              ilmin=min0(ilmin,iltest)
                           endif
                           wres(iv)=wres(iv)+il*wb(iv,imu,ipf,is)
                           if(im1.ne.0)then
                              wres(iv)=wres(iv)-w_rotres+(w_rot0
     &                             -abs(psiav(iv,imu,ipf,is))**p_rot
     &                             *(w_rot0-w_rot1))
                              wres_m1(iv,il)=wres(iv)
                           endif
                           if(itestil.eq.10.or.itestil.eq.20)then
                              write(*,'(7f11.5)') v(iv),wqvpr(iv,imu,ipf
     &                             ,is),wd(iv,imu,ipf,is),wb(iv,imu,ipf
     &                             ,is),wres(iv),q_av,psiav(iv,imu,ipf
     &                             ,is)
                           endif
                        enddo
                        nroot(il)=0
c     defining the resonance points
c     assume no more then two roots
                        if(nres.gt.1) then
                           call roots(wres(ires0),v(ires0),ind(1),nres
     $                          ,0.,eps,0.,vres(1,il),nroot(il))
                           vres_sat(ipf,imu,il,2,is)=vres(2,il)
                           vres_sat(ipf,imu,il,1,is)=vres(1,il)
#ifdef _dev
c this statement chooses 1 of two resonances for smooth representation in LBQ
                           if(is.eq.1) then
                              if(vres(2,il).gt.vres(1,il)) 
     &                             vres_sat(ipf,imu,il,1,is)=-vres(2,il)
                           endif
#endif
                        endif
                     endif
c /\ end of definition of the resonance velocity for a given IL
c \/ Start of resonance calculation for nroot(il) resonances
                     do ires=1,min0(2,nroot(il)),1
c
c     define critpoints for a given integrals
                        if(imtae.eq.min1) then
                           ires10=min0(nv-1,ind(ires)+ires0-1)
                           if(wb(ires10,imu,ipf,is)*wb(ires10+1,imu,ipf
     &                          ,is).eq.0.)then
                              psiavres(ires,il)=2.
                           else
                              rfres(2,6,ires,il)=v(ires10+1)-v(ires10)
                              alp2=(vres(ires,il)-v(ires10))/rfres(2,6
     &                             ,ires,il)
                              psiavres(ires,il)=(v(ires10+1)-vres(ires
     &                             ,il))/rfres(2,6,ires,il)
                              do i1=1,2
                                 do i2=1,4
                                    rfres(i1,i2,ires,il)=rf(i1,i2,imu
     &                                   ,ires10)*psiavres(ires,il)
     &                                   +rf(i1,i2,imu,ires10+1)*alp2
                                 enddo                           
                              enddo
                              wvpr_res=wvpr(ires10,imu,ipf,is)
     &                             *psiavres(ires,il)+wvpr(ires10+1,imu
     &                             ,ipf,is)*alp2
                              wb_res=wb(ires10,imu,ipf,is)*psiavres(ires
     &                             ,il)+wb(ires10+1,imu,ipf,is)*alp2
                              psiavres(ires,il)=psiav(ires10,imu,ipf,is)
     &                             *psiavres(ires,il)+psiav(ires10+1,imu
     &                             ,ipf,is)*alp2
                           endif
                        endif
c     calculation of Gm -> Re Gm = fo(2); Im Gm = fo(3);
c     write(*,*) imu,imtae,il
c     aeqv is an indicator, which shows that average refers to trapped
c     particles if it is -100.
c                        write(*,*) 'dintgr defin',imtae,min1,tb
c     &                       ,psiavres(ires,il),il
                        if(psiavres(ires,il).ge.1.)then
                           tb=0.
                        else 
                           call xaverage(hhh1,beqv,iav,iter,eps,epsp
     &                       ,fo(1,imtae0,il,ires),imtae,ntae,ntgr,psma
     &                       ,psmi,qpfi,pmui,r0,rma,rmi,rvpar,rfres(1,1
     &                       ,ires,il),sigm,symm,t0,tb,vres(ires,il),z0
     &                       ,xhp,real(wtae),wb_res,0.,wvpr_res)
                        endif
                        tbch(ires,il)=tb
c                        if(imtae.eq.min1) write(*,*) 
c     &                       '------------xav vs psiav>',
c     &                       xav,psiavres(ires,il),x2r
                        if(tb.gt.1.e-10.and.imtae.eq.min1) then
                           if(itestil.eq.1.or.itestil.eq.10)then
                              write(*,*) 'a,b=',hhh1,beqv
                              write(*,*) 'at m,l=',imtae,il
     &                             ,'ind,vres=',ind(ires)+ires0-1
     &                             ,vres(ires,il)
                           endif
                           aeqv(ires,il)=hhh1
c     if calculation is succesfull derivative is -> dwv, nres here is >= 2, often 4
c        it is dOmega(NOVA)/d(v/v0)
c                           call derivative(wres(ires0),v(ires0)
c     $                        ,nres,vres(ires,il)-0.01,dwvm,real(wtae))
c                           call derivative(wres(ires0),v(ires0)
c     $                        ,nres,vres(ires,il)+0.01,dwvp,real(wtae))
                           call derivative(wres(ires0),v(ires0)
     $                        ,nres,vres(ires,il),dwv,real(wtae))
c                           d2wv=(dwvp-dwvm)/0.02
c15
c                         if(ipf.eq.74.and.imu.eq.10.and.il.eq.-6) pause
c15
                           dwv_m1(ires,il)=dwv
                           ipfb=amin0(npf,ipf+1)
                           if(tip.eq.'r')then
                              if(wb(ires10,imu,ipfb,is).eq.0.)ipfb=ipfb
     &                             -1
                              if(wb(ires10,imu,ipfb-1,is).ne.0.)then
                                 dwbdpphi=(wb(ires10,imu,ipfb,is)
     &                                -wb(ires10,imu,ipfb-1,is))
     &                                /((qpf(ipfb)-qpf(ipfb-1))*wb_res)
                              else
                                 dwbdpphi=0.
                              endif
c                              write(*,*) wb(ires10,imu,ipf,is)
c     &                             ,wb(ires10+1,imu,ipf,is),wb_res
c     &                             ,ires10,ires0
c                              write(*,*) wb(ires10,imu,ipfb,is),
c     &                             wb(ires10,imu,ipfb-1,is),qpf(ipfb)
c     &                             ,qpf(ipfb-1)
                              call derivative(wb(ires0,imu,ipf,is)
     &                             ,v(ires0),nres,vres(ires
     &                             ,il),hhh1,wb_res)
c                              write(*,*) wb_res,vres(ires,il)
c                             here keep only velocity derivative
c                               add pitch angle later
                              wb_res=hhh1/wb_res
c                              pause
                           endif
c     following call is for equilibr. distr. function of alphas
c     derivatives dfalpdv,dfalpdpsi are normalized to V_al0,
c     Psi_edge and are in cm^-3
                           call distrfun(ai,b0*b0oo,dfalp(ires,il)
     &                          ,dfalpdv(ires,il),dfalpdpsi,dpga,eps
     &                          ,psiavres(ires,il),gam,hnub(ires,il),  !coll.scatt.freq. in 10^6 sec^-1
     &             hchirp(1,ires,il),ihsps,iter,qpfi,p0ga,pmui,rvpar   !hchirp(2,,) drag sl.d.freq.in sec^-1; (1,,) coll.scat. in sec^-1
     &                         ,sigm,tb,tip,vres(ires,il),vi,v(nv),0.,
     &                          z0,xhp,zi,dwbdpphi,wb_res,istart)
cdelete just a test line                           hnub(ires,il)=hnub(ires,il)*0.1
ckg_sat
                           fdist_sat(ipf,imu,il,ires,is)=dfalp(ires,il)
                           bgy_sat(ipf,imu,il,ires,is)=psiavres(ires,il)
                           meigfun(ipf,imu,il,ires,is)=imtae0
ckg_sat
                           if((tip.eq.'c')
     &                          .and.aeqv(ires,il).eq.-100)then
                              dfalpdv(ires,il)=dfalpdv(ires,il)*0.5
                              dfalpdpsi=dfalpdpsi*0.5
                              dfalp(ires,il)=dfalp(ires,il)*0.5
                           elseif(aeqv(ires,il).ne.-100)then
c this accounts for psi average dependence on v and lambda for passing particles
                              if(pmui.lt.r0.and.abs((psiavres(ires,il)
     &                             -qpfi)/((1.-pmui/r0))).lt.1.)then
                                 dfalpdv(ires,il)=dfalpdv(ires,il)+
     &                                dfalpdpsi*(psiavres(ires,il)-qpfi)
     &                                /((1.-pmui/r0)*vres(ires,il))
                              endif
                           endif
                           if(itestil.eq.1.or.itestil.eq.10)then
                              write(*,*)'tb,vres,dwv,dfalpdv,dfalpdpsi'
     &                             ,',fo',tb,vres(ires,il) 
     &                             ,dwv,dfalpdv(ires,il),dfalpdpsi,fo(2
     &                             ,imtae0,il,ires),fo(3,imtae0,il,ires)
     &                             ,psiavres(ires,il)
                           endif
c all are in NOVAK units
                           hhh1=tb*vres(ires,il)**6/abs(dwv)
                           dfgapdv(ires,il)=dfalpdv(ires,il)/
     $                          (omstar*vres(ires,il))+dfalpdpsi
                           dfalpdv(ires,il)=hhh1*(-dfalpdv(ires,il)
     $                          -omstar*vres(ires,il)*dfalpdpsi)
c                           dfdfdvdr(ipf,imu,il,ires,is)=
c     &                          -dfalpdv(ires,il)
c                           dfdfdvdr(ipf,imu,il,ires,is)=
c     &                          (-omstar*vres(ires,il)*dfalpdpsi)
                           dfdfdvdr(ipf,imu,il,ires,is)=-dfalpdv(
     $                      ires,il)-omstar*vres(ires,il)*dfalpdpsi
                           vgam_sat(ipf,imu,il,ires,is)=1.           ! was before tb*vres(ires,il)**6/abs(dwv)
                           tbres_sat(ipf,imu,il,ires,is)=tb
                           dwv_sat(ipf,imu,il,ires,is)=dwv
c  partial derivative of Omega over Pfi (no rotation so far)
c           looks like derivative of dwpfi between ipf and ipf+1(=ipfb)
                           dwpfi1=(-ntae*(wqvpr(ires10,imu,ipfb,is)
     &                          +wd(ires10,imu,ipfb,is))+real(wtae)
     &                          +il*wb(ires10,imu,ipfb,is)
     &                          -wres(ires10))/
     &                          (qpf(ipfb)-qpf(ipfb-1))
                           dwpfi1m=(-ntae*(wqvpr(ires10,imu,ipfb-2,is)
     &                          +wd(ires10,imu,ipfb-2,is))+real(wtae)
     &                          +il*wb(ires10,imu,ipfb-2,is)
     &                          -wres(ires10))/
     &                          (qpf(ipfb-2)-qpf(ipfb-1))
                           d2wpfim1=(dwpfi1-dwpfi1m)*2./
     &                          (qpf(ipfb-qpf(ipfb-2)))
c           looks like derivative of dwpfi between ipf and ipf+1 but at vres at ires+1
                           dwpfi=(-ntae*(wqvpr(ires10+1,imu,ipfb,is)
     &                          +wd(ires10+1,imu,ipfb,is))+real(wtae)
     &                          +il*wb(ires10+1,imu,ipfb,is)
     &                          -wres(ires10+1))/
     &                          (qpf(ipfb)-qpf(ipfb-1))
                           dwpfim=(-ntae*(wqvpr(ires10+1,imu,ipfb-2,is)
     &                          +wd(ires10+1,imu,ipfb-2,is))+real(wtae)
     &                          +il*wb(ires10+1,imu,ipfb-2,is)
     &                          -wres(ires10+1))/
     &                          (qpf(ipfb-2)-qpf(ipfb-1))
                           d2wpfip1=(dwpfi-dwpfim)*2./
     &                          (qpf(ipfb-qpf(ipfb-2)))
c     having those two derivatives we can interpolate dwpfi between them
                           dwpfi=dwpfi1-(dwpfi1-dwpfi)*(vres(ires,il)
     &                          -v(ires10))/(v(ires10+1)-v(ires10))
c     Berk's stuff is defined here
                           hwb1(ires,il)=(dwv+omstar*vres(ires,il)
     &                          *dwpfi)
c                           write(*,*) hnub(ires,il),hwb1(ires,il)
c     &                          ,'------------------'
c this becomes nu_eff^3 and in units 10^18 sec^{-3}, yes it does by having dOm/dv^prime in hwb1!!
                           hnub(ires,il)=hnub(ires,il)*(hwb1(ires,il)
     &                          *abs(wtae)*r0/real(ntae)/vi/10.)
     &                          **2*pmu(imu)/r0
c this is nu_se^2 in units sec^-2 ++
                           hnub_se(ires,il)=hchirp(2,ires,il)*1.e6*
     &             abs(hwb1(ires,il))*abs(wtae)*r0/real(ntae)/vi/10.
                           dfalp(ires,il)=dfalp(ires,il)*hhh1
c     c       this variable is the key to succesful resonance
                           dintgr(il,ires,4,2)=-1.01
                           if(im1.eq.0.or.im1.eq.3)then
c     Berk's stuff is added here
                           hwb=abs(hwb1(ires,il))*vres(ires,il)*
     &                             abs(wtae)/2.
c this is the abs value of the slanted derivative of Omega_res over (P_phi /psi0) at fixed mu
                           dwp_sat(ipf,imu,il,ires,is)=hwb1(ires,il)
     &                          /abs(omstar*vres(ires,il))
cnng15 in 10^0 whatever units
                           hwb1(ires,il)=hwb**1.5/hnub(ires,il)
                           endif
c     
                        else if(imtae.eq.min1)then
                           dintgr(il,ires,4,2)=0.
c exclude these resonance points
                           if(tb.lt.1.e-10) then
c
                              bgy_sat(ipf,imu,il,ires,is)=-100.
                              vres_sat(ipf,imu,il,ires,is)=0.
                           endif
                        endif
 32                        continue
                     enddo
c     /\ end of resonance points definition for multiple resonances
c
c M1 stability is initiated here
c:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
               if(im1.ne.0.and.im1.ne.3)then
                  if(pk.ne.1.) stop 'pk.ne.1.'
                  do ivm1=1,nv
                     if(ivm1.eq.ind(1).or.ivm1.eq.ind(1)+1.or.(nroot(0)
     &                    .gt.1.and.(ivm1.eq.ind(2).or.ivm1.eq.ind(2)
     &                    +1)).or.(nroot(0).gt.2.and.ivm1.ge.ind(3)))
     &                    then 
                        i_m1(ivm1,il)=1
                     else
                        i_m1(ivm1,il)=0
                     endif
                     if(nroot(0).gt.2.and.ivm1.ge.ind(3).or.imu_m1.eq
     &                    .imu)goto33
                     if(abs(wb(ivm1,imu,ipf,is)).gt.1.e-10) then
                     if(imtae.eq.min1) then
c     define critpoints for a given integrals
                        do i1=1,2
                           do i2=1,4
                              rf_m1(i1,i2,ivm1)=rf(i1,i2,imu,ivm1)
                           enddo                           
                        enddo
                     endif
c     calculation of Gm -> Re Gm = fo(2); Im Gm = fo(3);
c     write(*,*) imu,imtae,il
c     aeqv is an indicator, which shows that average refers to trapped
c     particles if it is -100.
                     call xaverage(hhh1,beqv,iav,iter,eps,epsp
     $                    ,fo_m1(1,ivm1,imtae0,il),imtae,ntae,ntgr
     &                    ,psma,psmi,qpfi,pmui,r0,rma,rmi,rvpar
     &                    ,rf_m1(1,1,ivm1),sigm,symm,t0,tb
     &                    ,v(ivm1),z0,xhp,real(wtae),wb(ivm1,imu,ipf,is)
     &                    ,wres(ivm1),wvpr(ivm1,imu,ipf,is))
                     if(hhh1.eq.-100..and.imu_m1.eq.0)imu_m1=imu
                     if(imtae.eq.min1) then
                        if(itestil.eq.20)then
                           write(*,*) 'a,b=',hhh1,beqv
                           write(*,*) 'at m,l=',imtae,il,'ind,vres='
     &                          ,ind(1)+ires0-1,vres(1,il)
                        endif
c     following call is for equilibr. distr. function of alphas
c     derivatives dfalpdv,dfalpdpsi are normalized to V_al0,
c     Psi_edge and are in cm^-3
                        dwbdpphi=0.
                        wb_res=0.
                        call distrfun(ai,b0*b0oo,dfal,dfalpdv_m1(ivm1,il
     &                       ),dfalpdpsi,dpga,eps,psiav(ivm1,imu,ipf,is)
     &                    ,gam,hhh1,hhh2,ihsps,iter,qpfi,p0ga,pmui,rvpar
     &                       ,sigm,tb,tip,v(ivm1),vi,v(nv),0.,z0,xhp,zi
     &                       ,dwbdpphi,wb_res,istart)
                        if((tip.eq.'c').and
     &                       .hhh1.eq.-100)then
                           dfalpdv_m1(ivm1,il)=dfalpdv_m1(ivm1,il)*0.5
                           dfalpdpsi=dfalpdpsi*0.5
                           dfal=dfal*0.5
                        elseif(hhh1.ne.-100)then
c this accounts for psi average dependence on v and lambda for passing particles
                           if(pmui.lt.r0.and.abs((psiavres(ires,il)
     &                          -qpfi)/((1.-pmui/r0))).lt.1.)then
                              dfalpdv(ires,il)=dfalpdv_m1(ivm1,il)+
     &                             dfalpdpsi*(psiav(ivm1,imu,ipf,is)
     &                             -qpfi)/((1.-pmui/r0)*v(ivm1))
                           endif
                        endif
                        if(itestil.eq.20)then
                           write(*,*)'tb,vres,dwv,dfalpdv,dfalpdpsi'
     &                          ,',fo,psiaver',tb,vres(1,il),dwv
     &                          ,dfalpdv(1,il),dfalpdpsi,fo(2,imtae0,il
     &                          ,1),fo(3,imtae0,il,1),psiav(ivm1,imu,ipf
     &                          ,is)
                        endif
                        hhh1=tb*v(ivm1)**6
                        dfalpdv_m1(ivm1,il)=hhh1*(
c     &                       -omstar*v(ivm1)*dfalpdpsi)
     &                       -dfalpdv(ires,il)*(
c     &                        sign(abs(wtae),real(wtae))
     &                       -w_rotres+(w_rot0-
     &                       abs(psiav(ivm1,imu,ipf,is))**p_rot*
     &                       (w_rot0-w_rot1)))
     &                       /sign(abs(wtae),real(wtae))
     &                       -omstar*v(ivm1)*dfalpdpsi)
c     
                     endif
                     endif
 33                  continue
                  enddo
c     /\ end of velocity integration definition for principal part
c     
               endif
c End of M1 initiation
c:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
                  enddo
c     /\ end of bounce harmonic sum - il
               enddo
c     /\ end of poloidal harmonic definition - imtae
c     we assemble here all quantities
c......................................................................
               xmlmax=0.
               hhh=0.
               imlmax=0.
               imtamax=0
               xmtamax=0.
               do il=ml10,ml2
                  hhh11=0.
                  do ires=1,min0(2,nroot(il)),1
                     if(abs(dintgr(il,ires,4,2)+1.01).lt.0.01)then
                        hhh1=0.
                        hhh2=0.
                        do imtae=min1+1-min,max1+1-min
                           hhh1=hhh1+fo(2,imtae,il,ires)
                           hhh2=hhh2+fo(3,imtae,il,ires)
                           hhh111=sqrt(fo(2,imtae,il,ires)**2+fo(3,imtae
     &                          ,il,ires)**2)
                           if(xmtamax.lt.hhh111) then
                              xmtamax=hhh111
                              imtamax=imtae-1+min
                           endif
                           if(itestm.eq.1)write(*,*) 'tst1',imtae,fo(2
     &                          ,imtae,il,ires),fo(3,imtae,il,ires)
                        enddo
c                        if(itest.eq.1)then
c                           if(itestm.eq.1)write(*,*) 'tst2',ires,il,hhh1
c     &                          ,hhh2
c                           write(*,*) 'nu_eff,v,dg',(hnub(ires,il)*
c     &                          1.e+18)**(1./3.),vres(ires,il),hhh1
c                        endif
                        hhh1=hhh1**2+hhh2**2
                        hhh11=0.
                        hhh2=0.
                        do imtae=min1+1-min,max1+1-min
                           hhh11=hhh11+fo(5,imtae,il,ires)
                           hhh2=hhh2+fo(4,imtae,il,ires)
                        enddo
                        if(itestm.eq.1)write(*,*) 'tst3',ires,il,hhh11
     &                       ,hhh2
                        hhh2=hhh2**2+hhh11**2
cberk
                        if(im1.eq.0.or.im1.eq.3)then
c this is with FLr corrections
                        hhh2b=hhh2
ctune this is without FLR and is good for benchmarks with other codes,
c     which do not have FLR                         hhh2b=hhh1
                        hhb=dfalpdv(ires,il)*hhh2b
c                write(*,*) 'dfalpdv=',dfalpdv(ires,il),ipf,ires,is,il
c                        if((itest.eq.1).and.(imu.eq.imu1t).and.
c     &                   (ipf.eq.ipf1t).and.(ires.eq.1).and.(is.eq.1)
c     &                       .and.(il.eq.il1t)) 
c     &                       write(*,*) 'dfalpdv=',dfalpdv(ires,il)
c this is 2 omega_b / (d Omega /d P_phi) normalized to sqrt(delta B_max/B); need it
                        wbwpi_sat(ipf,imu,il,ires,is)=2.e+6*(hnub(ires,
     &                       il)*hwb1(ires,il))**(1/3.)*hhh2b**(1/4.)
     &                      /(dwp_sat(ipf,imu,il,ires,is)*sqrt(dbobmax))
c                        dwv_sat(ipf,imu,il,ires,is)=2.e+6*(hnub(ires,il)
c     &                       *hwb1(ires,il))**(1/3.)*hhh2b**(1/4.)
c     &                      /(dwp_sat(ipf,imu,il,ires,is)*sqrt(dbobmax))
c d.b. nu_eff/omega, exponentials are kept to clearly see where they come from
                        hnub_sat(ipf,imu,il,ires,is)=(hnub(ires,il)*
     &                       1.e+18)**(1./3.)/(real(wtae)*10**6)
                        do ib=1,iberk
                           ug=(dbob(ib)/(dbobmax*2))**1.5*hwb1(ires,il)
     &                          *(hhh2b)**(3./4.)
                           ug=amax1(ug,1.e-9)
c     nizhnyaya chast'
                           gberkintmu(imu,ib,2)=gberkintmu(imu,ib,2)
     &                          +hhb
c     for averaging the effective scattering frequency (sec^-3)
                           gberkintmu(imu,ib,3)=gberkintmu(imu,ib,3)
     &                          +hhb*(hnub(ires,il)*1.e+18)
cdel-old-Vini-contrib-from dPfi **(1./3.)
cdel     averaging <omega_b^2> (sec^-1) (looks like does include dOm/dPf downstairs through hnub above)
                           gberkintmu(imu,ib,4)=gberkintmu(imu,ib,4)
     &                          +hhb*(ug*hnub(ires,il)*1.e+18)**0
     &                          .66666666667
c     verkhnyaya chast' верхняя часть  
                           gberkintmu(imu,ib,1)=gberkintmu(imu,ib,1)
c note that this /(1.+.57 ... is from original berk paper. 
     &                          +hhb/(1.+.57*ug/(1.+1.45/ug)**.3333)
                        enddo
c drag, sl.down freq. in sec-2 (c.f. with hnub). here vi is from v_f*R0[m]
c     1.e6 is from freq. units as others are incorporated into R0 and vi
c     and thus into Pphi and other exprns
c coll.sl.down in sec^-2
                        gberkimuch(imu,2)=gberkimuch(imu,2)+
     &                     hhb*hnub_se(ires,il)
c                    following expr integrand in VD last eq in 
c                            /u/Ql../Ql../ChirpStabXtendExt.pdf
                           do idrg=1,iberk
                              do isct=1,iberk
cnng                  ratio of scatt/drag ^\/^ frqncs is this first parameter
                        if(tbch(ires,il).gt.1.e-5) then
                                 call chirpcritvd(hchirp(1,ires,il)*
     &                                gbiscl(isct)/(hchirp(2,ires,il)*
     &                                gbiscl(idrg)), xint)
                         gbimuch(imu,idrg,isct)=gbimuch(imu,idrg,isct)+
     &                                dfgapdv(ires,il)*hhh2b*hhh2b*
     &                                abs(dwp_sat(ipf,imu,il,ires,is))
     &                              *tbch(ires,il)*xint/(hchirp(2,ires,
cnng                  finally the multiplier vres^2 accounts for the d lambda which should be 
cnng                   coming from d mu in the formulations
     &                            il)*gbiscl(idrg))**4*vres(ires,il)**2
                        endif
                              enddo
                           enddo
                           gbimuch0(imu)=gbimuch0(imu)+dfgapdv(ires,
     &                          il)*hhh2b*hhh2b*abs(dwp_sat(ipf,imu,
     &                          il,ires,is))*tbch(ires,il)/
     &                          hchirp(2,ires,il)**4*vres(ires,il)**2
                           gbidrgavmu(imu,1)=gbidrgavmu(imu,1)+
     &                          hchirp(1,ires,il)*hhb
                           gbidrgavmu(imu,2)=gbidrgavmu(imu,2)+
     &                          hchirp(2,ires,il)*hhb
c
cdel-old-Vinic-contrib-from dPfi xchrp(2,ires,il)
c     &                   *1.e6*vi*dwp_sat(ipf,imu,il,ires,is)/xhp
cdel-old-Vinic-contrib-from dPfi
c coll. scatt. freq. (hnub is nu_eff^3 and in units 10^18 sec^{-3}) +
                        gberkimuch(imu,1)=gberkimuch(imu,1)+
     &                     hhb*hnub(ires,il)*1.e+18
c *abs(dwp_sat(     &                       ipf,imu,il,ires,is))**2 wrong multipl,i.e. double counting dwp
                        gbidrgavmu(imu,3)=gbidrgavmu(imu,3)+
     &                       (1./(hnub(ires,il)*1.e+18
c *abs(dwp_sat(  ipf,imu,il,ires,is))**2 wrong multipl,i.e. double counting dwp
     &                     )**1.3333)*hhb
                        gbidrgavmu(imu,4)=gbidrgavmu(imu,4)+
     &                       1./(hchirp(2,ires,il)**4)*hhb
cdel-old-Vinic-contrib-from  hchirp(1,ires,il)*xchrp(1,ires,il)
cdel-old-Vinic-contrib-from     &              *(vi*1.e6*dwp_sat(ipf,imu,il,ires,is)/xhp)**2
c
                        endif
c     /\ End of poloidal harmonic assembly
c     c       this variable keeps res. velocity 
                        dintgr(il,ires,3,2)=vres(ires,il)
c     c       this variable keeps res. contrib. w/o  FLR
                        dintgr(il,ires,1,2)=dfalp(ires,il)*hhh1
c     c       this variable keeps res. contrib. with FLR
                        dintgr(il,ires,2,2)=dfalp(ires,il)*hhh2
c                        write(*,*) dfalpdv(ires,il),dfalp(ires,il)
                        hhh1=dfalpdv(ires,il)*hhh1
                        hhh=hhh+hhh1
ckg_sat RBQ, the same names are in RBQ.fweb file
                        vgam_sat(ipf,imu,il,ires,is)=vgam_sat(ipf,imu,
     &                       il,ires,is)*hhh2
c                        dfdfdvdr(ipf,imu,il,ires,is)=dfalpdv(ires,il)
                        hhh2=dfalpdv(ires,il)*hhh2
                        if(itestm.eq.1)write(*,*) 'tst4',ires,il,hhh1
     &                       ,hhh2,dfalpdv(ires,il)
                        hhh11=hhh1
ckg_sat
                        gam_sat(ipf,imu,il,ires,is)=hhh2
ckg_sat
                        if(vres(ires,il).lt.1..or.tip.eq.'m'.or.tip
     &                       .eq.'e'.or.tip.eq.'h'.or.tip.eq.'i'.or.tip
     &                       .eq.'r'.or.tip.eq.'x') then
c     passing w/o FLR
                           gamintmu(imu,1)=gamintmu(imu,1)+hhh1
                        else
                           gamintmu(imu,5)=gamintmu(imu,5)+hhh1
                        endif
c     trapped w/o FLR
                        if(aeqv(ires,il).eq.-100.) then
                           if(vres(ires,il).lt.1..or.tip.eq.'m'.or
     &                          .tip.eq.'e'.or.tip.eq.'h'.or.tip.eq.'i'
     &                          .or.tip.eq.'r'.or.tip.eq.'x')then
                              gamintmu(imu,3)=gamintmu(imu,3)+hhh1
                           else
                              gamintmu(imu,7)=gamintmu(imu,7)+hhh1
                           endif
                        endif
c     trapped w FLR
                        if(aeqv(ires,il).eq.-100.) then
                           if(vres(ires,il).lt.1..or.tip.eq.'m'.or
     &                          .tip.eq.'e'.or.tip.eq.'h'.or.tip.eq.'i'
     &                          .or.tip.eq.'r'.or.tip.eq.'x')then
                              gamintmu(imu,4)=gamintmu(imu,4)+hhh2
                           else
                              gamintmu(imu,8)=gamintmu(imu,8)+hhh2
                           endif
                        endif
c     passing w FLR
                        if(vres(ires,il).lt.1..or.tip.eq.'m'.or.tip
     &                       .eq.'e'.or.tip.eq.'h'.or.tip.eq.'i'.or.tip
     &                       .eq.'r'.or.tip.eq.'x') then
                           gamintmu(imu,2)=gamintmu(imu,2)+hhh2
                        else
                           gamintmu(imu,6)=gamintmu(imu,6)+hhh2
                        endif
                        if(itestil.eq.1.or.itestil.eq.10)then
                           write(*,*) 'Mmax',imtamax,' il',il,tb,hhh
     &                          ,vres(ires,il),dwv,' ml10,ml2',ml10
     &                          ,ml2
                           write(*,*) 'With FLR',hhh2,' W/o FLR'
     &                          ,hhh11
                        endif
c     c     Calculation of the cutoff contribution at v=v_\alpha0
                        if(imu.gt.1.and.dintgr(il,ires,4,2).eq
     &                       .dintgr(il,ires,4,1).and.(dintgr(il
     &                       ,ires,3,2)-1.)*(dintgr(il,ires,3,1)-1.
     &                       ).le.0..and.tip.ne.'m'.and.tip.ne.'e'
     &                       .and.tip.ne.'h'.and.tip.ne.
     &                       'i'.and.tip.ne.'r'.and.tip.ne.'x')then
c     cutoff passing and trapped particles w/o FLR
                           hhh1=(dintgr(il,ires,1,1)
     &                          +dintgr(il,ires,1,2))*0.5
ctune mozhet?    &                          *(dintgr(il
c     &                          ,ires,3,2)-1.)+dintgr(il,ires,1,2)
c     &                          *(1.-dintgr(il,ires,3,1)))
c     &                          /(dintgr(il,ires,3,2)-dintgr(il
c     &                          ,ires,3,1))
     &                          /abs(dintgr(il,ires,3,2)
     &                          -dintgr(il,ires,3,1))*abs(pmu(imu)
     &                          -pmu(imu-1))
                           gamintpfi(ipf,3,is)=gamintpfi(ipf,3,is)
     &                          +hhh1
c     cutoff passing and trapped particles with FLR
                           hhh2=(dintgr(il,ires,2,1)
     &                          +dintgr(il,ires,2,2))*0.5
c     &                          *(dintgr(il
c     &                          ,ires,3,2)-1.)+dintgr(il,ires,2,2)
c     &                          *(1.-dintgr(il,ires,3,1)))
c     &                          /(dintgr(il,ires,3,2)-dintgr(il
c     &                          ,ires,3,1))
     &                          /abs(dintgr(il,ires,3,2)
     &                          -dintgr(il,ires,3,1))*abs(pmu(imu)
     &                          -pmu(imu-1))
                           gamintpfi(ipf,4,is)=gamintpfi(ipf,4,is)+hhh2
c     write(*,*) ires,imtae,il,hhh1,hhh2
c     cutoff trapped particle contribution to cutoff
                           if(aeqv(ires,il).eq.-100.) then
                              gtrap(ipf,3)=gtrap(ipf,3)+hhh1
                              gtrap(ipf,4)=gtrap(ipf,4)+hhh2
                           endif
c        yn=(f(1)*(x(2)-xn)+f(2)*(xn-x(1)))/(x(2)-x(1))
                        endif
                     endif
                     if(xmlmax.lt.abs(hhh11))then
                        xmlmax=abs(hhh11)
                        imlmax=il
                     endif
                  enddo
               enddo
c /\ End of bounce harmonic and multiple resonances assembly
c......................................................................
c
c M1 stability is integrated here
c:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
               if(im1.ne.0.and.im1.ne.3)then
               do il=ml10,ml2
                  do ivm1=1,nv
                     if(i_m1(ivm1,il).eq.1)goto34
                     if(abs(wb(ivm1,imu,ipf,is)).gt.1.e-10.and.imu.ne
     &                    .imu_m1) then
                        hhh11=0.
                        hhh1=0.
                        hhh2=0.
                        do imtae=min1+1-min,max1+1-min
                           hhh1=hhh1+fo_m1(2,ivm1,imtae,il)
                           hhh2=hhh2+fo_m1(3,ivm1,imtae,il)
                        enddo
                        hhh1=hhh1**2+hhh2**2
                        hhh11=0.
                        hhh2=0.
                        do imtae=min1+1-min,max1+1-min
                           hhh11=hhh11+fo_m1(5,ivm1,imtae,il)
                           hhh2=hhh2+fo_m1(4,ivm1,imtae,il)
                        enddo
                        hhh2=hhh2**2+hhh11**2
cAtra(x,y,nns,res)
c     /\ End of poloidal harmonic sum
                        wres_av=wres_m1(ivm1,il)
c-real(wtae)
                        hhh1=dfalpdv_m1(ivm1,il)*hhh1/wres_av
                        hhh2=dfalpdv_m1(ivm1,il)*hhh2/wres_av
                        omintmu(imu,1)=omintmu(imu,1)+hhh1*(v(2)-v(1))
                        omintmu(imu,2)=omintmu(imu,2)+hhh2*(v(2)-v(1))
                      endif
  34                  continue
                  enddo
                  do ires=1,min0(2,nroot(0)),1
                     if(abs(dintgr(0,ires,4,2)+1.01).lt.0.01.and
     &                    .vres(ires,0).lt.1.)then
                        isign=-3
                        do ivm1=ind(ires),ind(ires)+1
                        isign=isign+2
                        hhh11=0.
                        hhh1=0.
                        hhh2=0.
                        do imtae=min1+1-min,max1+1-min
                           hhh1=hhh1+fo_m1(2,ivm1,imtae,il)
                           hhh2=hhh2+fo_m1(3,ivm1,imtae,il)
                        enddo
                        hhh1=hhh1**2+hhh2**2
                        hhh11=0.
                        hhh2=0.
                        do imtae=min1+1-min,max1+1-min
                           hhh11=hhh11+fo_m1(5,ivm1,imtae,il)
                           hhh2=hhh2+fo_m1(4,ivm1,imtae,il)
                        enddo
                        hhh2=hhh2**2+hhh11**2
cAtra(x,y,nns,res)
                        hhh1=real(isign)*dfalpdv_m1(ivm1,il)*hhh1
     &                       /dwv_m1(ires,0)
                        hhh2=real(isign)*dfalpdv_m1(ivm1,il)*hhh2
     &                       /dwv_m1(ires,0)
                        omintmu(imu,1)=omintmu(imu,1)+hhh1
                        omintmu(imu,2)=omintmu(imu,2)+hhh2
                        enddo
                     endif
                  enddo
               enddo
               endif
c End of M1 integration
c:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
               do ki=1,8
                  gamintmu(imu,ki)=gamintmu(imu,ki)*gamkom
                  if(ki.lt.3)omintmu(imu,ki)=omintmu(imu,ki)*gamkom
ckg dopolnitel'nyi mnozhitel' dlya testa s MGD glob codom byl /4.
     &                 /2./3.1415926
               enddo
               if(itest.eq.1)then
                  write(*,*) '-----------------------------------------'
                  write(*,*) 'mu(',imu,')=', pmu(imu), ' A=',aeqv(1,
     &                 imlmax)
                  write(*,*) 'Minm,Maxm=',min1,max1
     &                 ,'il_at_max,HHmax=',imlmax,xmlmax
                  write(*,*)'ILmin,Ilmax=',ml10,ml2,gamintmu(imu,1)
     &                 ,gamintmu(imu,5),gamintmu(imu,3),gamintmu(imu,7)
     &                 ,imu,' (m)',imtamax
c????????????????
     +                 ,dfalp(ires,il),dfalpdv(ires,il),dfalpdpsi
                  write(*,*)'Princpart=',omintmu(imu,1),omintmu(imu,2)
                  write(*,*)'with FLR',gamintmu(imu,2),gamintmu(imu,4)
               endif
               call equiv(dintgr(-mtl,1,1,1),dintgr(-mtl,1,1
     &              ,2),(2*mtl+1)*nnres*4)
               call zero(dintgr(-mtl,1,1,2),nnres*(2*mtl+1)*4)
            enddo
c /\ end of MU - pitch angle integration loop
            call asimp(pmu,gamintmu(1,1),nmu,gamintpfi(ipf,1,is))
            call asimp(pmu,gamintmu(1,2),nmu,gamintpfi(ipf,2,is))
            do ib=1,iberk
               call asimp(pmu,gberkintmu(1,ib,1),nmu,gberkintpfi(ipf
     &              ,ib,2*is-1))
               call asimp(pmu,gberkintmu(1,ib,2),nmu,gberkintpfi(ipf
     &              ,ib,2*is))
               call asimp(pmu,gberkintmu(1,ib,3),nmu,gberkintpfi(ipf
     &              ,ib,4+is))
               call asimp(pmu,gberkintmu(1,ib,4),nmu,gberkintpfi(ipf
     &              ,ib,6+is))
            enddo
            call asimp(pmu,gberkimuch(1,1),nmu,gberkipfich(ipf,1,is))
            call asimp(pmu,gberkimuch(1,2),nmu,gberkipfich(ipf,2,is))
            do idrg=1,iberk
               do isct=1,iberk
                  call asimp(pmu,gbimuch(1,idrg,isct),nmu,gbipfich(
     &                 ipf,idrg,isct,is))
               enddo
            enddo
            call asimp(pmu,gbimuch0(1),nmu,gbipfich0(ipf,is))
            call asimp(pmu,gbidrgavmu(1,1),nmu,gbidrgavipfi(ipf,is,1))
            call asimp(pmu,gbidrgavmu(1,2),nmu,gbidrgavipfi(ipf,is,2))
            call asimp(pmu,gbidrgavmu(1,3),nmu,gbidrgavipfi(ipf,is,3))
            call asimp(pmu,gbidrgavmu(1,4),nmu,gbidrgavipfi(ipf,is,4))
            if(is.eq.1) then
               call asimp(pmu,gamintmu(1,3),nmu,gtrap(ipf,1))
               call asimp(pmu,gamintmu(1,4),nmu,gtrap(ipf,2))
               call asimp(pmu,gamintmu(1,7),nmu,gtrap(ipf,5))
               call asimp(pmu,gamintmu(1,8),nmu,gtrap(ipf,6))
            endif
            call asimp(pmu,omintmu(1,1),nmu,hhh1)
            omintpfi(ipf,1)=omintpfi(ipf,1)+hhh1
            call asimp(pmu,omintmu(1,2),nmu,hhh2)
            omintpfi(ipf,2)=omintpfi(ipf,2)+hhh2
c            write(*,*) 'Here is gamu',(gamintmu(i,5),i=1,nmu)
c            write(*,*) '----'
            call asimp(pmu,gamintmu(1,5),nmu,gamintpfi(ipf,5,is))
            call asimp(pmu,gamintmu(1,6),nmu,gamintpfi(ipf,6,is))
c            write(*,*) ' ZOW>0,<0,TRPD=',gamintpfi(ipf,1,1)
c     &           ,gamintpfi(ipf,1,2),gtrap(ipf,1)
c            write(*,*) ' Cutoff, >0,<0',gamintpfi(ipf,3,1)*gamkom
c     &           ,gamintpfi(ipf,3,2)*gamkom,gtrap(ipf,2)*gamkom
            if(ipf.eq.npf.or.mod(ipf,3).eq.0)then
            open(unit=18,file=filename,status='unknown')
            write(18,*) is,ipf+1
            write(18,*) gamkomis,omkomis,gtrap1
            write(18,*) gamintpfi
            write(18,*) omintpfi
            write(18,*) gtrap
            write(18,*) gberkintpfi
            write(18,*) gberkis
            write(18,*) gberkipfich
            write(18,*) gberkisch
            write(18,*) gbipfich,gbipfich0
            write(18,*) gbisch,gbisch0
            close(18)
            endif
            if(im1.ne.1)then
               write(*,*) 'At is,ipf=',is,ipf,' gam`s=',gamintpfi(ipf,1
     ^              ,is),gamintpfi(ipf,3,is)*gamkom,gamintpfi(ipf,5,is)
            else
               write(*,*) 'At is,ipf=',is,ipf,' gam`s=',gamintpfi(ipf,1
     ^              ,is),gamintpfi(ipf,3,is)*gamkom,gamintpfi(ipf,5,is)
     ^              ,'dW_r=',omintpfi(ipf,1)
            endif
 119        call zero(dintgr(-mtl,1,1,1),nnres*(2*mtl+1)*8)
         enddo
c /\ end of integration in minor radius, i.e. P_phi
         if(itest.ne.1) ipf1t=1
         do ib=1,iberk
            call asimp(qpf,gberkintpfi(1,ib,2*is-1),npf,gberkis(ib,2*is
     &           -1))
            call asimp(qpf,gberkintpfi(1,ib,2*is),npf,gberkis(ib,2*is))
            call asimp(qpf,gberkintpfi(1,ib,4+is),npf,gberkis(ib,4+is))
            call asimp(qpf,gberkintpfi(1,ib,6+is),npf,gberkis(ib,6+is))
         enddo
         call asimp(qpf,gberkipfich(1,1,is),npf,gberkisch(1,is))
         call asimp(qpf,gberkipfich(1,2,is),npf,gberkisch(2,is))
         do idrg=1,iberk
            do isct=1,iberk
               call asimp(qpf,gbipfich(1,idrg,isct,is),npf,gbisch
     &              (idrg,isct,is))
            enddo
         enddo
         call asimp(qpf,gbipfich0(1,is),npf,gbisch0(is))
         call asimp(qpf,gbidrgavipfi(1,is,1),npf,gbidrgavis(is,1))
         call asimp(qpf,gbidrgavipfi(1,is,2),npf,gbidrgavis(is,2))
         call asimp(qpf,gbidrgavipfi(1,is,3),npf,gbidrgavis(is,3))
         call asimp(qpf,gbidrgavipfi(1,is,4),npf,gbidrgavis(is,4))
c
         call asimp(qpf,gamintpfi(1,1,is),npf,gamkomis(1,is))
         call asimp(qpf,gamintpfi(1,2,is),npf,gamkomis(2,is))
         call asimp(qpf,gamintpfi(1,3,is),npf,gamkomis(3,is))
         gamkomis(3,is)=gamkomis(3,is)*gamkom
         call asimp(qpf,gamintpfi(1,4,is),npf,gamkomis(4,is))
         gamkomis(4,is)=gamkomis(4,is)*gamkom
         call asimp(qpf,gamintpfi(1,5,is),npf,gamkomis(5,is))
         call asimp(qpf,gamintpfi(1,6,is),npf,gamkomis(6,is))
         call asimp(qpf,omintpfi(1,1),npf,hhh1)
         omkomis(1)=omkomis(1)+hhh1
         call asimp(qpf,omintpfi(1,2),npf,hhh2)
         omkomis(2)=omkomis(2)+hhh2
         if(is.eq.1) then
            call asimp(qpf,gtrap(1,1),npf,gtrap1(1))
            call asimp(qpf,gtrap(1,2),npf,gtrap1(2))
            call asimp(qpf,gtrap(1,3),npf,gtrap1(3))
            gtrap1(3)=gtrap1(3)*gamkom
            call asimp(qpf,gtrap(1,4),npf,gtrap1(4))
            gtrap1(4)=gtrap1(4)*gamkom
            call asimp(qpf,gtrap(1,5),npf,gtrap1(5))
            call asimp(qpf,gtrap(1,6),npf,gtrap1(6))
         endif
      enddo
c /\ end of integration for co(+trapped) and contragoing particles. 
c_________graph\/stuff
      if(im1.ne.1) then
      write(*,*)' dB/B,  Gam_d/Gam_l, <(om_b)^2,sec^-2>'
ckg
      do ib=1,iberk
         hhh1=(gberkis(ib,1)+gberkis(ib,3))/(gberkis(ib,2)
     &        +gberkis(ib,4))
         hhh2=(gberkis(ib,5)+gberkis(ib,6))/(gberkis(ib,2)
     &        +gberkis(ib,4))
         write(*,'(4e18.11)') dbob(ib),hhh1,
c hhh2**(1./3.),
     &     (gberkis(ib,7)+gberkis(ib,8))/(gberkis(ib,2)+gberkis(ib,4))
      enddo
      ib=1
      print *,' Res.summ of eff.aver. scatt, in sec^-1', 
     &     abs((gberkisch(1,1)+gberkisch(1,2))/(gberkis(ib,2)+gberkis(
     &     ib,4)))**(1./3.),' vs drag. in sec^-1 ',sqrt(abs((gberkisch
     &     (2,1)+gberkisch(2,2))/(gberkis(ib,2)+gberkis(ib,4))))
c
      do idrg=1,iberk
         do isct=1,iberk
            gbimap(idrg,isct)=(gbisch(idrg,isct,1)+gbisch(idrg,isct,2))
     &        /(gbisch0(1)+gbisch0(2))
         enddo
      enddo
c Comp. as stated, i.e. no eff. multiplication
      write(*,*) ' Phase space averaged scatt and drag in sec^-1 are',
     & (gbidrgavis(1,1)+gbidrgavis(2,1))/(gberkis(ib,2)+gberkis(ib,4)),
     & (gbidrgavis(1,2)+gbidrgavis(2,2))/(gberkis(ib,2)+gberkis(ib,4))
c Here scatt freq. is given in units of sec^-1, i.e. with Omega given in 10^6 and Pphi normalized to Psi0
      write(*,*)' Phase space averged <1/scatt,eff^4>,<1/drag^4> sec^4',  
     & (gbidrgavis(1,3)+gbidrgavis(2,3))/(gberkis(ib,2)+gberkis(ib,4)),
     & (gbidrgavis(1,4)+gbidrgavis(2,4))/(gberkis(ib,2)+gberkis(ib,4))
ckg
      gamkomT=gamkomis(1,1)+gamkomis(1,2)+gamkomis(3,1)+gamkomis(3,2)
      gamkomflr=gamkomis(2,1)+gamkomis(2,2)+gamkomis(4,1)+gamkomis(4,2)
      write(*,*) 'growth rate`s are'
      write(*,*)'---------------------------------------------------'
      write(*,*) 'Positive passing w/o  FLR w/o cutoff',gamkomis(1,1)
     &     -gtrap1(1)
      write(*,*) 'Positive passing w/o  FLR at sing. cutoff',gamkomis(3
     &     ,1)-gtrap1(3)
      write(*,*) 'Positive passing w/o  FLR at nonsing. cutoff'
     &     ,gamkomis(5,1)-gtrap1(5)
      write(*,*)'........flr'
      write(*,*) 'Positive passing with FLR w/o cutoff',gamkomis(2,1)
c     &     -gtrap1(1)*gamkomis(2,1)/gamkomis(1,1)
     &     -gtrap1(2)
      write(*,*) 'Positive passing with FLR at sing. cutoff',gamkomis(4
     &     ,1)-gtrap1(4)
      write(*,*) 'Positive passing with FLR at nonsing. cutoff'
     &     ,gamkomis(6,1)-gtrap1(6)
      write(*,*)'---------------------------------------------------'
      write(*,*) 'Negative passing w/o  FLR w/o cutoff',gamkomis(1,2)
      write(*,*) 'Negative passing w/o  FLR at sing. cutoff',gamkomis(3
     &     ,2)
      write(*,*) 'Negative passing w/o  FLR at nonsing. cutoff'
     &     ,gamkomis(5,2)
      write(*,*)'........flr'
      write(*,*) 'Negative passing with FLR w/o cutoff',gamkomis(2,2)
      write(*,*) 'Negative passing with FLR at sing. cutoff',gamkomis(4
     &     ,2)
      write(*,*) 'Negative passing with FLR at nonsing. cutoff'
     &     ,gamkomis(6,2)
      write(*,*)'---------------------------------------------------'
      write(*,*) 'Trapped w/o  FLR w/o cutoff',gtrap1(1)
      write(*,*) 'Trapped w/o  FLR at sing. cutoff',gtrap1(3)
      write(*,*) 'Trapped w/o  FLR at nonsing. cutoff',gtrap1(5)
      write(*,*)'........flr'
      write(*,*) 'Trapped w  FLR w/o cutoff',gtrap1(2)
      write(*,*) 'Trapped w  FLR at sing. cutoff',gtrap1(4)
      write(*,*) 'Trapped w  FLR at nonsing. cutoff',gtrap1(6)
      write(*,*)'---------------------------------------------------'
      write(*,*) 'Total growth rate w/o FLR',gamkomT
      write(*,*) 'Total growth rate withFLR',gamkomflr
ckg writing simple output
      write(57,*) '>Finite Orbit Width res. (FOW) for fast ion specie:'
      write(57,*) ' Mass/m_p'
      write(57,*) ai
      write(57,*) ' Charge/e_p'
      write(57,*) zi
      write(57,*) ' Velocity in 10^9 cm/sec'
      write(57,*) vi
      write(57,*) ' Va/Valfv='
      write(57,*) vi/valfv
      if(tip.ne.'x') then
         write(57,*) 'Fast ion growth rate w/o FLR, gam_h'
         write(57,*) gamkomT
         write(57,*) 'Fast ion growth rate withFLR, gam_hFLR'
         write(57,*) gamkomflr
      else
         write(57,*) 'gam_iLandau with FLR, FOW, of m_i',ai
         write(57,*) gamkomflr
      endif
      write(57,*) 'Critical beta is to be calculated'
      write(57,*) 'beta_hcrit=-beta_h*(all dampings above)/gam_h or '
      write(57,*) 'beta_hcrit=-beta_h*(all dampings above)/gam_hFLR or '
      close(57)
      open(57,file='smpl_out',status='unknown')
      read(57,*)
      read(57,*) gcontL
      read(57,*)
      read(57,*) gecoll
      read(57,*)
      read(57,*) geL
      read(57,*)
      read(57,*) gDL
      read(57,*)
      read(57,*) gTL
      read(57,*)
      read(57,*) gHL
      read(57,*)
      read(57,*) gCL
      read(57,*)
      read(57,*) grL
      gdTot=grL+gCL+gHL+geL+gecoll+gcontL+gTL+gDL
c  excluding some damping can be done by hands but must be commented below
      close(57)
ckg
      endif
      write(*,*) 'Principal part w/o FLR',omkomis(1)
      write(*,*) 'Principal part with FLR',omkomis(2)
      omkom=omkomis(1)
      omkomflr=omkomis(2)
      open(unit=18,file=filename,status='unknown')
      write(18,*) is-1,ipf
      write(18,*) gamkomis,omkomis,gtrap1
      write(18,*) gamintpfi
      write(18,*) omintpfi
      write(18,*) gtrap
      write(18,*) gberkintpfi
      write(18,*) gberkis
      write(18,*) gberkipfich
      write(18,*) gberkisch
      write(18,*) gbipfich,gbipfich0
      write(18,*) gbisch,gbisch0
      close(18)
cnng15 u4m add growth rate
c     ?Xin file for TAE structure and normalization is created here.
c      To proceed with all the files (after they are created) use command 
c             ls kXin*w.* > kXin.dat
c In each file kXin* beam growth rate are included only when run for alphas 
c is done (after beams are done), otherwise it makes the amplitude predictions 
c only with the current (alphas or beams) growth rates so it makes sense
c to run alphas (after beam runs) to include both in amplitude evluation.
c In alpha growth calculations we recreate a file with the name Xin..mode. The 
c code does it autmatically.
      c46=
     &"ls -l eigenf|awk '{print $NF}'>/tmp/buff"
      call system(c46)
      open(11,file='/tmp/buff',status='old')
      read(11,*) c46
c read the egn.. like file name for the mode
      egnid= trim(adjustl(c46))
      close(11)
      if(c46(1:3).eq.'egn') then
c make an egn....mode from it
         c46="sed s/'egn'/'Xin'/ /tmp/buff > /tmp/buff1"
         call system(c46)
c open Xin..mode file, where Xin.. file has like-Xin01w.... name in it
         open(11,file='/tmp/buff1',status='old')
         read(11,*) c46
         write(*,*) trim(adjustl(c46))
         close(11)
c modify the file to add other information: gdTot and gamkomT (or with/w/o FLR gamkomflr/gamkomT)
         write(cgw(1:60),'(5e12.4)') abs(real(wtae))*1000*0.5/3.1415926,
     &     gamkomflr,gdTot,ximax,dnonmax
c change its contents to add frequencies and growth rates
         call system("sed s/'6 ;S'/'11 ;S'/ "//c46//" > /tmp/buff")
         call system
     &   ("sed s/' ;N'/'"//cgw(1:60)//" ;N'/ /tmp/buff > /tmp/buff1")
         call system(
     &      "sed s/'igrid;'/'igrid,gw[kHz],gwkwFlr,gdTot;'/
     &      /tmp/buff1>/tmp/buff")
c here careful check should be done for gdTot summation - 
c all terms or not are included? grL=RadDamp;...
         call system(
     &"sed s/'gdTot;'/'gdTot=grad+gCL+gHL+geL+gecoll+gcontL+gTL;'/
     &/tmp/buff> /tmp/buff1")

         write(*,*) c46
c        call system("sed s/'gTL;'/'gTL+gDL,Xi[m],dn/n;'/
         call system("sed s/'gTL;'/'gTL+gDL,Xi[m],dn\/n;'/
     &     /tmp/buff1> k"//c46)
cremoving buff files not to interfair with other users
         call system("rm -rf /tmp/buff")
         call system("rm -rf /tmp/buff1")
      else
         write(*,*) 
     &  'Sorry, can not modify Xin??w.* like files with structures'
      endif
cnng14 read runid for a given transp.dat run if it exists
      inquire (FILE='transp.dat', EXIST=transp_exist)
      if(transp_exist) then 
         open(18,file='transp.dat',status='old')
         read(18,'(a90)') runid
         i=1
         do while (runid(i:i).ne.'=')
            i=i+1
c            print *,runid(i:i)
         enddo
         it=i+20
         do while (runid(it:it).ne.'=')
            it=it+1
c            print *,runid(it:it)
         enddo
         it=it+2
         close(18)
      else
         i=0
         runid(1:9)='nonameNng'
      endif
cnng16 here we are saving the arrays for 2D contour map of the chirping stability boundary
      write(nus,'(2f9.3)') (gbidrgavis(1,1)
     &+gbidrgavis(2,1))/(gberkis(ib,2)+gberkis(ib,4)),
     &(gbidrgavis(1,2)+gbidrgavis(2,2))/(gberkis(ib,2)+gberkis(ib,4))
c after the following dump, to look at the map do this:
c   /u/ngorelen/work/exe/contmap4u.py Out/contmap.u4m
      call dump24mat(gbiscl,gbiscl,gbimap,iberk,iberk,runid(i+1:i+9),
     &        trim(adjustl(runid(it:90))), egnid, nus)
c
#ifdef _dev
c     Use u4mat described in /u/ngorelen/SRC/u4mat.lyx
c         old formatted file is dumped in dump_sat above
c
c define indexes to the most of possible array indexes
c change of plans: do this for the whole resonance, not at specific ipf
      ires=1
c    idlt=4 ! this is for 2*4+1 = 9 harmonics to be accounted for in RBQ analysis 
      idlt=3 ! this is smaller but sufficient to get 7 harmonics for RBQ runs
      idlt=12 ! this is for 2*12+1 = 25
      i1D=1                     !this is equidistant in velocity, which is for 1D case
      if(pk==0.5) then
         i1D=2                  !this is equidistant in energy, which is for 2D case
      endif
      open(unit=18,file='gxm'//c46(3:15)//'.u4m',status='unknown')
      write(18,*) 'gxm elements; runid ',runid(i+1:i+9),'; time ',
     & trim(adjustl(runid(it:90))),'; mode ',c46(3:15),';'
      write(18,*) 18                    !number of sequences (arrays) ; added imtae0 (meigfun)
      write(18,*) 0,23,';Sclrs;Nsclrs;' !0 for scalars (1st array); 21 for number of scalars
      write(18,*) npf,nmu,mtl_m1,2,ntae,real(wtae),gamkom,            !  7 consts
     &    idlt*2+1,vi,ai,zi,omstar,i1D,xhp,psitot,r0,valfv*10./r0,    !+10 consts
     &     gdTot-grL-gcontL,gamkomflr,ximax,dbobmax,min,pk,           !+ 6 consts
     &     ';npf,nmu,mtl_m1,2,ntae',
     &     ',wtae[10^6/sec],gamkom,idlt2+1,vi,ai,zi,omstar,i1D,xhp',
     &     ',psitot,rax,walfv[10^6/sec],gdTot,gghN,Xi[m],dB/B,minm,pk;' !first sequence/array of scalars
cnng16 
      do imu=1,nmu
c reuse aeqv array to find the dominant resonances
         do is=1,2
            call zero(aeqv, nnres*(2*mtl+1))
            do ipf=1,npf
               do il=-mtl,mtl
c identify double resonant location and put on the first place the resonance with largest resonant velocity
                  if(vres_sat(ipf,imu,il,ires,is).lt.0.001) then
                     vres_sat(ipf,imu,il,ires,is)=
     &                    abs(vres_sat(ipf,imu,il,ires,is))
                     dwv_sat(ipf,imu,il,ires,is)=
     &                    dwv_sat(ipf,imu,il,2,is)
                     fdist_sat(ipf,imu,il,ires,is)=
     &                    fdist_sat(ipf,imu,il,2,is)
                     gam_sat(ipf,imu,il,ires,is)=
     &                    gam_sat(ipf,imu,il,2,is)
                     vgam_sat(ipf,imu,il,ires,is)=
     &                    vgam_sat(ipf,imu,il,2,is)
                     tbres_sat(ipf,imu,il,ires,is)=
     &                    tbres_sat(ipf,imu,il,2,is)
c
                     dfdfdvdr(ipf,imu,il,ires,is)=
     &                    dfdfdvdr(ipf,imu,il,2,is)
                     dwp_sat(ipf,imu,il,ires,is)=
     &                    dwp_sat(ipf,imu,il,2,is)
                     hnub_sat(ipf,imu,il,ires,is)=
     &                    hnub_sat(ipf,imu,il,2,is)
                     bgy_sat(ipf,imu,il,ires,is)=
     &                    bgy_sat(ipf,imu,il,2,is)
                     wbwpi_sat(ipf,imu,il,ires,is)=
     &                    wbwpi_sat(ipf,imu,il,2,is)
                  endif
                  hhhgam=abs(gam_sat(ipf,imu,il,ires,is))
                  aeqv(1,il)=aeqv(1,il)+hhhgam
commented in work/nova/d3d_153071Duarte/comments_controltests
c                  if(imu.eq.8.and.il.eq.-4) print *,
c     & ' --<< ipf,is,vres_sat,gam_sat',ipf,is,
c     & vres_sat(ipf,imu,il,ires,is),gam_sat(ipf,imu,il,ires,is)
               enddo            !end of il loop
            enddo               !       ipf loop
c after integration check the maximum harmonic contribution
            hhh=0.
            ihhh=0
            do il=-mtl,mtl
               hhhgam=abs(aeqv(1,il))
               if(hhh.lt.hhhgam)then
                  hhh=hhhgam
                  ihhh=il
               endif
            enddo               ! il loop search for max abs value
c
c using maximum m information define needed harmonics for each imu
            if(-mtl.ge.ihhh-idlt) then
               indx_sat(imu,is)=-mtl
            elseif(mtl.le.ihhh+idlt) then
               indx_sat(imu,is)=mtl-2.*idlt
            elseif(hhh.lt.1.e-3)then
               indx_sat(imu,is)=-mtl
            else
               indx_sat(imu,is)=ihhh-idlt
            endif
c     define array for minimization of the Taylor expansion of the Omega
            do il=indx_sat(imu,is),indx_sat(imu,is)+2*idlt
               do ipf=1,npf
                  do iv=1,nv
                     wresPfiV(ipf,iv)= -ntae*(wqvpr(iv,imu,ipf,is)
     &                    +wd(iv,imu,ipf,is))+real(wtae)
     &                    +il*wb(iv,imu,ipf,is)
c
                  enddo
               enddo
c     find approximate polynomial expansions at the resonance along the P_phi direction 
c     and along the slanted direction involving both v and P_phi
c         this loop is entered each time for each harmonics and if there is a resonance
               do ipf=1,npf
                  if(vres_sat(ipf,imu,il,ires,is).gt.0.001) then
                     ifail=0
                     if( i1D == 1 ) then
                        call wresminimize(wresPfiV(1,1),dwp_sat(ipf,imu,
     ^                       il,ires,is),dwpmnmz_sat(ipf,imu,il,ires,is)
     ^                       ,d2wpmnmz_sat(ipf,imu,il,ires,is),nmu,imu
     ^                       ,npf,nv,qpf,v ,qpf(ipf),vres_sat(ipf,imu,il
     ^                       ,ires,is),  0.  ,wb(1,1,1,is),ifail)
                     else
                        call wresminimize(wresPfiV(1,1),dwp_sat(ipf,imu,
     ^                       il,ires,is),dwpmnmz_sat(ipf,imu,il,ires,is)
     ^                       ,d2wpmnmz_sat(ipf,imu,il,ires,is),nmu,imu
     ^                       ,npf,nv,qpf,v ,qpf(ipf),vres_sat(ipf,imu,il
     ^                       ,ires,is),omstar,wb(1,1,1,is),ifail)
                     endif
#ifdef _test1
                        write(*,'(2e12.4,a,2e12.4,a,e12.4,4i4)')
     ^                       vres_sat(ipf,imu,il,ires,is),qpf(ipf),'('
     ^                       ,dwp_sat(ipf,imu,il,ires,is)
     ^                       ,dwpmnmz_sat(ipf,imu,il,ires,is),')'
     ^                       ,d2wpmnmz_sat(ipf,imu,il,ires,is),ipf ,imu
     ^                       ,il,is
#endif
                  endif
               enddo
            enddo               ! il loop over maximum harmonics contributions
         enddo                  ! is loop for sigma||
      enddo                     ! is loop for mu
      write(18,*) 1,2,'; grps2; rgrid; vs nosurf;'
      write(18,*) nosurf,'; grps2;'
      write(18,*) grps2(1:nosurf)
      write(18,*) nosurf,'; rgrid;'
      write(18,*) rgrid(1:nosurf)
      write(18,*) 2,2,'; indx_sat; eigfun; vs nmu,2 and vs nn,mt;'
      write(18,*) nmu*2,'; indx;'
      write(18,*) indx_sat      !second sequence
c saving the radial displacement for RBQ through a separate subroutine 
      call savexi(18) 
      write(18,*)  5,13,'; dwv_sat; vres_sat; fdist_sat; gam_sat; ',
     &'vgam_sat; tbres_sat; dwp_sat; dwpmnmz_sat; d2wpmnmz_sat; ',
     &'hnub_sat; bgy_sat; wbwpi_sat; meigfun; vs npf,nmu,idlt*2+1,1,2;'

      write(18,*) npf*nmu*(2*idlt+1)*1*2,'; dwv;'
      write(18,*) ((((dwv_sat(ipf,imu,il,ires,is),il=
     &                       indx_sat(imu,is),indx_sat(imu,is)+2*idlt),
     &                       is=1,2),
     &                       imu=1,nmu),
     &                       ipf=1,npf)      !third and so on sequences
      write(18,*) npf*nmu*(2*idlt+1)*1*2,'; vres;'
      write(18,*)(((( vres_sat(ipf,imu,il,ires,is),il=indx_sat(imu
     &    ,is),indx_sat(imu,is)+2*idlt),is=1,2),imu=1,nmu),ipf=1,npf)

      write(18,*) npf*nmu*(2*idlt+1)*1*2,'; fdist;'
      write(18,*)((((fdist_sat(ipf,imu,il,ires,is),il=indx_sat(imu
     &    ,is),indx_sat(imu,is)+2*idlt),is=1,2),imu=1,nmu),ipf=1,npf)

      write(18,*) npf*nmu*(2*idlt+1)*1*2,'; gam;'
      write(18,*)((((  gam_sat(ipf,imu,il,ires,is),il=indx_sat(imu
     &    ,is),indx_sat(imu,is)+2*idlt),is=1,2),imu=1,nmu),ipf=1,npf)

      write(18,*) npf*nmu*(2*idlt+1)*1*2,'; vgam;'
      write(18,*)(((( vgam_sat(ipf,imu,il,ires,is),il=indx_sat(imu
     &    ,is),indx_sat(imu,is)+2*idlt),is=1,2),imu=1,nmu),ipf=1,npf)

      write(18,*) npf*nmu*(2*idlt+1)*1*2,'; tbres'
      write(18,*)(((( tbres_sat(ipf,imu,il,ires,is),il=indx_sat(imu
     &    ,is),indx_sat(imu,is)+2*idlt),is=1,2),imu=1,nmu),ipf=1,npf)

      write(18,*) npf*nmu*(2*idlt+1)*1*2,'; dwp;'
      write(18,*)((((  dwp_sat(ipf,imu,il,ires,is),il=indx_sat(imu
     &    ,is),indx_sat(imu,is)+2*idlt),is=1,2),imu=1,nmu),ipf=1,npf)

      write(18,*) npf*nmu*(2*idlt+1)*1*2,'; dwpmnmz;'
      write(18,*)((((  dwpmnmz_sat(ipf,imu,il,ires,is),il=indx_sat(imu
     ^     ,is),indx_sat(imu,is)+2*idlt),is=1,2),imu=1,nmu),ipf=1,npf)

      write(18,*) npf*nmu*(2*idlt+1)*1*2,'; d2wpmnmz;'
      write(18,*)((((  d2wpmnmz_sat(ipf,imu,il,ires,is),il=indx_sat(imu
     ^     ,is),indx_sat(imu,is)+2*idlt),is=1,2),imu=1,nmu),ipf=1,npf)

      write(18,*) npf*nmu*(2*idlt+1)*1*2,'; hnub;'
      write(18,*)(((( hnub_sat(ipf,imu,il,ires,is),il=indx_sat(imu
     &    ,is),indx_sat(imu,is)+2*idlt),is=1,2),imu=1,nmu),ipf=1,npf)
c an averaged psi for d.f. computations
      write(18,*) npf*nmu*(2*idlt+1)*1*2,'; bgy;'
      write(18,*)((((  bgy_sat(ipf,imu,il,ires,is),il=indx_sat(imu
     &    ,is),indx_sat(imu,is)+2*idlt),is=1,2),imu=1,nmu),ipf=1,npf)
      write(18,*) npf*nmu*(2*idlt+1)*1*2,'; wbwpi;'
      write(18,*)((((  wbwpi_sat(ipf,imu,il,ires,is),il=indx_sat(imu
     &    ,is),indx_sat(imu,is)+2*idlt),is=1,2),imu=1,nmu),ipf=1,npf)
      write(18,*) npf*nmu*(2*idlt+1)*1*2,'; meigfun;'
      write(18,*)(((( meigfun(ipf,imu,il,ires,is),il=indx_sat(imu
     &    ,is),indx_sat(imu,is)+2*idlt),is=1,2),imu=1,nmu),ipf=1,npf)
      close(18)
c----------------------DF dump -----------------------
#endif
c      idumpdf=0
c this directive just simiplifies the program by commenting one if statement to lower the used dimenstions
#ifdef dumpdf
c      idumpdf=1
c      if(idumpdf.ne.0)then
c_dev this part is to plot the distribution function at a chosen velocity
c_dev Choose the velocity first by choosing index of v array from 1 to nv
         if(tip.ne.'q')then
c     this value corresponds roughly to half input energy of hot ions if
            ivc=nv/v(nv)*0.7
c but we have to choose it equal to the Alfven speed
            ivc=nv*valfv/(v(nv)*vi)
         else
c     because of high normalized velocity in cql3d case we need to be
c     closer to low values of the velocity index
c and now we make it closer to the Alfven speed
            ivc=nv*valfv/(v(nv)*vi)
         endif
c check if the fundamental resonance is outside of the velocity limits
c     and if it is take 1/3, which is tipically in this limits,
c     otherwise be  close to the latest one
         if(ivc.ge.nv)ivc=ivc/3
         ivc=min0(nv,ivc)
         ivc=max0(2,ivc)
         labtitle='distr.function'
c         open(unit=18,file='df_type_'//tip(1:1)//'.bdat',form=
c     &        'unformatted',status='unknown')
         open(unit=18,file='df_type_'//tip(1:1)//'.bdat',
     &        status='unknown')
         imuax=indx(pmu(1),nmu,r0)
c         write(*,*) '*** in growth imuax=',imuax
c choose Pphi index at R_LFS corresponding to the maximum of mode amplitude
         ratmax=ratpsii(isrfmax,psii,bii)
         ipfmax=indx(qpf,npf,psii)
c
         do iv=1,nv
            do ipf=1,npf
               do imu=1,nmu
                  do is=1,2
                     sigm=1.
                     if(is.eq.2) sigm=-1.
ckg                  write(*,*) iv,ipf,imu,is
                     if(iv.eq.38.and.imu.eq.106.and.ipf.eq.81.and
     &                    .is.eq.1)then
                        continue
                        wb(iv,imu,ipf,is)=wb(iv,imu,ipf,is)
                     endif
                     if(psiav(iv,imu,ipf,is).le.1..and.
     &                    psiav(iv,imu,ipf,is).gt.0.)then
                        call distrfun(ai,b0*b0oo,dfal,dfalpdv,dfalpdpsi,
     &                  dpga,eps,psiav(iv,imu,ipf,is),gam,hhh1,
     &                  gbisch0(1),ihsps,
     &                  iter,qpf(ipf),p0ga,pmu(imu),rvpar,sigm,tb,tip,
     &                  v(iv),vi,v(nv),0.,z0,xhp,zi,dwbdpphi,wb_res,
     &                       istart)
c     hchirp(1)=coll.scat. in sec^-1
c     kg                  write(*,*) 'grprpl',iv,ipf,imu,is,v(iv)
                        fplot1(imu,iv,is)=dfal+fplot1(imu,iv,is)
                        if(iv.eq.ivc) fplot(ipf,imu,is)=dfal
                        if(is.eq.2.and.iv.eq.ivc) fplot(ipf,imu,1)=fplot
     &                       (ipf,imu,1)+fplot(ipf,imu,2)
c     if(ipf.eq.ipfmax.and.(1.-pmu(imu)*bii/(r0*b0).gt.0.)
                        if(ipf.eq.ipfmax)then 
                           if(is.eq.1)then
                              imui=nmu-imu+1
                              isi=2
                           else
                              imui=imu
                              isi=1
                           endif
                           gc2(imui,isi,nv)=sqrt(abs(1.-pmu(imu)*bii/
     &                          (r0*b0)))*sigm
                           fplot2(imui,isi,iv)=dfal
                        endif
                        f_coarse(iv,imu,ipf,is)=dfal
                        hnub_coarse(iv,imu,ipf,is)=abs(pmu(imu)/
     &                   r0)*gbisch0(1)*(xfow*xhp*v(iv)*r0)**2    ! r0 is raxis; what is missing here is Btor/B ??? in sec^-1 * ( ~ pfi / chi)^2
c                        hnub_coarse(iv,imu,ipf,is)=gbisch0(1)*                  ! in sec^-1 * (pfi / chi)^2
c     &                       ((qpf(ipf)-psiav(iv,imu,ipf,is)))**2               ! what is missing here is /chi ???
                     else
                        wb(iv,imu,ipf,is)=0.
                        psiav(iv,imu,ipf,is)=0.
                     endif
                  enddo
               enddo
            enddo
         enddo
         continue
         ipfmax=ipfmax
         write(18,*) npf,nmu,nv,2
         write(18,*) r0,v(ivc),v(nv),vi,ratmax,psii,valfv
         write(18,*) qpf
         write(18,*) pmu
         write(18,*) v
         write(18,*) fplot
         write(18,*) fplot1
c output v||/v for the distribution function (next line) taken at the LFS point 
         write(18,*) gc2
         write(18,*) fplot2
         close(18)
cnng14 we dump the coarse DF for further use in the LBQ code. Note that
cnn       this should work for any mode at a given transp run, which we 
cnn       identify with the id written at the top of u4m file && idumpdf==1
cnng14 dump the DF array
         open(18,file='dfRbq.u4m',status='unknown')
         write(18,*) 'DF; runid ',runid(i+1:i+9),'; time ',
     &        trim(adjustl(runid(it:90))),';'
         write(18,*) '7'
         write(18,*) 1,3,'; qpf; pmu; v;'
         write(18,*) npf,' ; qpf;'
         write(18,*) (qpf(i),i=1,npf)
         write(18,*) nmu,' ; pmu;'
         write(18,*) (pmu(i),i=1,nmu)
         write(18,*) nv,' ; v; pk=',pk
         write(18,*) (v(i),i=1,nv)
         write(18,*) '4 4 ; df_coarse; wbounce; psiav; nusct; '                          ! 4 dmsns & 4 N of arrays
         write(18,*) npf*nmu*nv*2,'; df_coarse [cm^-3];'
         write(18,*) ((((f_coarse(iv,imu,ipf,is),iv=1,nv),imu=1,nmu)
     &        ,ipf=1,npf),is=1,2)
c         write(18,*) npf*nmu*nv*2,'; phidot|| [10^6 sec^-1];'
c         write(18,*) ((((wqvpr(iv,imu,ipf,is+wd(iv,imu,ipf,is)),iv=1,nv)
c     &        ,imu=1,nmu),ipf=1,npf),is=1,2)
         write(18,*) npf*nmu*nv*2,'; wbounce [10^6 sec^-1];'
         write(18,*) ((((wb(iv,imu,ipf,is),iv=1,nv),imu=1,nmu)
     &        ,ipf=1,npf),is=1,2)
         write(18,*) npf*nmu*nv*2,'; psiav ;'
         write(18,*) ((((psiav(iv,imu,ipf,is),iv=1,nv),imu=1,nmu)
     &        ,ipf=1,npf),is=1,2)
         write(18,*) npf*nmu*nv*2,'; nusct sec^-1 * (pfi / chi)^2;'
         write(18,*) ((((hnub_coarse(iv,imu,ipf,is),iv=1,nv),imu=1,nmu)
     &        ,ipf=1,npf),is=1,2)
cnng15  for LBQ we also need more information, such as drift frequencies going into
cnn         the resonance condition 
c                                 wqvpr(iv,imu,ipf
c     &                             ,is),wd(iv,imu,ipf,is),wb(iv,imu,ipf
c     &                             ,is),wres(iv),

         
         close(18)
c      endif
#endif
c
      if(im1.eq.0.or.im1.eq.3)then
ckg analytical estimates of fast ion contribution to m=1/n=1 stabilization
         call gg_ae_theory(ihsps,immax,isrfmax,wtae,omstar
     &        ,b0oo,valfv/vi,ai,zi,vi)
      endif
c      if(im1.eq.1.or.im1.eq.0) return
      if(im1.eq.3.or.im1.eq.1.or.im1.eq.0) return
      do i=1,npf
c passing particles only without FLR and cutoff
         gamintpfi(i,1,1)=abs(gamintpfi(i,1,1)-gtrap(i,1)+
     &        gamintpfi(i,1,2))*2.*sqrt(abs(qpf(i)))
c trapped particles only without FLR and cutoff
         gtrap(i,1)=abs(gtrap(i,1))*2.*sqrt(abs(qpf(i)))
         if(qpf(i).lt.0.) then
            qpf(i)=-sqrt(abs(qpf(i)))
         else
            qpf(i)=sqrt(abs(qpf(i)))
         endif
      enddo
c
c passing particles only without FLR and cutoff
      call twodgraf(qpf,gamintpfi(1,1,1),npf,1,col(1),pat(1),'white'
     $     ,2,'Passing_w/o_cutoff','sqrt(P_phi)'
     &     ,'d(gam/om)/dsqrt(P_phi)','FOW',6,6,1,wd,0)
      call frame(0)
c trapped particles only without FLR and cutoff
      call twodgraf(qpf,gtrap(1,1),npf,1,col(1),pat(1),'white'
     $     ,2,'Trapped_w/o_cutoff','sqrt(P_phi)'
     &     ,'d(gam/om)/dsqrt(P_phi)','FOW',6,6,1,wd,0)
      call frame(0)
      do i=1,npf
         gamintpfi(i,1,1)=abs(gamintpfi(i,3,1)-gtrap(i,3)+
     &        gamintpfi(i,3,2))*2.*abs(qpf(i)*gamkomhlp)
         gtrap(i,1)=abs(gtrap(i,3))*2.*abs(qpf(i)*gamkomhlp)
      enddo
      if(tip.eq.'h'.or.tip.eq.'i'.or.tip.eq.'m'.or.tip.eq.'e'.or.tip.eq.
     &    'r'.or.tip.eq.'x')return
c
c passing particles only without FLR at cutoff
      call twodgraf(qpf,gamintpfi(1,1,1),npf,1,col(1),pat(1),'white'
     $     ,2,'Passing_cutoff','sqrt(P_phi)','d(gam/om)/dsqrt(P_phi)'
     &     ,'FOW',6,6,1,wd,0)
      call frame(0)
c trapped particles only without FLR at cutoff
      call twodgraf(qpf,gtrap(1,1),npf,1,col(1),pat(1),'white'
     $     ,2,'Trapped_cutoff','sqrt(P_phi)','d(gam/om)/dsqrt(P_phi)'
     &     ,'FOW',6,6,1,wd,0)
      call frame(0)
c      return
      do i=1,npf
         gamintpfi(i,1,1)=abs(gamintpfi(i,5,1)-gtrap(i,5)+
     &        gamintpfi(i,5,2))*2.*abs(qpf(i))
         gtrap(i,1)=abs(gtrap(i,5))*2.*abs(qpf(i))
      enddo
c
c passing particles only without FLR after cutoff
      call twodgraf(qpf,gamintpfi(1,1,1),npf,1,col(1),pat(1),'white'
     $     ,2,'Passing_za_cutoff','sqrt(P_phi)','d(gam/om)/dsqrt(P_phi)'
     &     ,'FOW',6,6,1,wd,0)
      call frame(0)
c trapped particles only without FLR after cutoff
      call twodgraf(qpf,gtrap(1,1),npf,1,col(1),pat(1),'white'
     $     ,2,'Trapped_za_cutoff','sqrt(P_phi)','d(gam/om)/dsqrt(P_phi)'
     &     ,'FOW',6,6,1,wd,0)
      bmax=0.
      return
      end
